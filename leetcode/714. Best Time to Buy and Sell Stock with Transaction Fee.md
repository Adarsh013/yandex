Задача в том, чтобы найти максимальную прибыль, которую можно получить при покупке и продаже акций с учётом комиссии за каждую транзакцию. Дан массив цен на акции и фиксированная комиссия за каждую транзакцию. Необходимо найти максимальную прибыль, которую можно получить, совершив несколько транзакций (покупка и продажа считаются за одну транзакцию), при условии, что при продаже акций необходимо учитывать комиссию.

Алгоритм решения:

- Создаем две переменные: `buy` и `sell`, которые будут хранить максимальную прибыль при покупке и продаже соответственно.
- Инициализируем переменные `buy` и `sell` значением `-prices[0]` и `0` соответственно, так как мы считаем, что покупаем акции в первый день.
- Проходим по массиву цен на акции, начиная со второго элемента.
- Для каждой цены находим максимальную прибыль, которую можно получить, совершив транзакцию в этот день.
- Если максимальная прибыль минус комиссия больше, чем текущее значение `buy`, то обновляем значение `buy`.
- Если максимальная прибыль плюс текущая цена минус комиссия больше, чем текущее значение `sell`, то обновляем значение `sell`.
- Возвращаем значение `sell`, которое является максимальной прибылью, которую можно получить при покупке и продаже акций с учетом комиссии за каждую транзакцию.

```go
package main

func maxProfit(prices []int, fee int) int {
	if len(prices) == 0 {
    return 0
  }
	buy, sell := -prices[0], 0
	for _, price := range prices[1:] {
		sell = max(sell, buy+price-fee)
		buy = max(buy, sell-price)
	}
	return sell
}

func max(x, y int) int {
	if x > y {
		return x
	}
	return y
}

func main() {
	var prices []int
	// Input: prices = [1,3,2,8,4,9], fee = 2
	// Output: 8
	// Explanation: The maximum profit can be achieved by:
	// - Buying at prices[0] = 1
	// - Selling at prices[3] = 8
	// - Buying at prices[4] = 4
	// - Selling at prices[5] = 9
	// The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.
	prices = []int{1, 3, 2, 8, 4, 9}
	println(maxProfit(prices, 2))
	// Input: prices = [1,3,7,5,10,3], fee = 3
	// Output: 6
	prices = []int{1, 3, 7, 5, 10, 3}
	println(maxProfit(prices, 3))
}
```

Алгоритмическая сложность функции `maxProfit()` равна `O(n)`, где `n` - это количество элементов в списке `prices`.

Это потому, что функция проходит по всем элементам списка `prices` только один раз, выполняя постоянное количество операций для каждого элемента.

Таким образом, время выполнения функции пропорционально количеству элементов в списке, что соответствует `O(n)` времени работы.

---

```go
func maxProfit(prices []int, fee int) int {
	buy, sell := -prices[0], 0
	for _, price := range prices[1:] {
		tmp := buy
		buy = max(buy, sell-price)
		sell = max(sell, tmp+price-fee)
	}
	return sell
}
```

На самом деле "tmp" не нужен, хотя он может облегчить чтение кода.

Если buy не обновляется в день i, то tmp == buy.
Если buy обновляется в день i, то tmp != buy. Обратите внимание, что buy обновляется, потому что мы продаем в день i. Для оптимальной прибыли мы не покупаем в тот же день, а значит, sell остаётся sell.

Я отбрасываю "tmp", и код принимается.
