Задача в том, чтобы угадать число, которое загадал компьютер. Компьютер выбирает число от 1 до n, а вы должны угадать это число, задавая вопросы, на которые компьютер отвечает "больше", "меньше" или "угадал".

Для решения этой задачи можно использовать алгоритм двоичного поиска. Мы будем делить диапазон возможных чисел пополам и спрашивать компьютер, находится ли загаданное число в первой или второй половине диапазона. Затем мы будем продолжать делить диапазон пополам до тех пор, пока не угадаем число.

```go
package main

// -1: Your guess is higher than the number I picked (i.e. num > pick).
// 1: Your guess is lower than the number I picked (i.e. num < pick).
// 0: your guess is equal to the number I picked (i.e. num == pick).
func guess(num, pick int) int {
	if pick == num {
		return 0
	} else if num > pick {
		return -1
	} else {
		return 1
	}
}

func guessNumber(n, pick int) int {
	left, right := 1, n
	for left <= right {
		mid := (left + right) / 2
		res := guess(mid, pick)
		if res == 0 {
			return mid
		} else if res == 1 {
			left = mid + 1
		} else {
			right = mid - 1
		}
	}
	return -1
}

func main() {
	// Input: n = 10, pick = 6
	// Output: 6
	n := 10
	pick := 6
	println(guessNumber(n, pick))
}
```

В этом коде мы используем переменные left и right для хранения границ диапазона возможных чисел. Затем мы используем цикл for, чтобы продолжать делить диапазон пополам до тех пор, пока не угадаем число.

Внутри цикла мы вычисляем среднее значение mid, используя формулу (left + right) / 2. Затем мы вызываем функцию guess(mid), чтобы узнать, находится ли загаданное число в первой или второй половине диапазона.

Если guess(mid) возвращает 0, то мы угадали число и возвращаем mid. Если guess(mid) возвращает 1, то загаданное число больше mid, поэтому мы обновляем значение left на mid + 1. Если guess(mid) возвращает -1, то загаданное число меньше mid, поэтому мы обновляем значение right на mid - 1.

Если мы не угадали число до конца цикла, то возвращаем -1.

Алгоритмическая сложность функции `guessNumber()` равна `O(log n)`, где `n` - максимальное значение, которое может принимать параметр. Это связано с тем, что функция использует бинарный поиск, который каждый раз уменьшает количество элементов, которые нужно проверить вдвое. Количество шагов, необходимых для поиска числа, пропорционально логарифму от `n`, что дает алгоритмическую сложность `O(log n)`.
