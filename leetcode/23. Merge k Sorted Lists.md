Задача в том, чтобы объединить k отсортированных связанных списков в один отсортированный связанный список.

```go
package main

type ListNode struct {
	Val  int
	Next *ListNode
}

func mergeKLists(lists []*ListNode) *ListNode {
	if len(lists) == 0 {
		return nil
	}
	return merge(lists, 0, len(lists)-1)
}

func merge(lists []*ListNode, left int, right int) *ListNode {
	if left == right {
		return lists[left]
	}
	mid := (left + right) / 2
	leftList := merge(lists, left, mid)
	rightList := merge(lists, mid+1, right)
	return mergeTwoLists(leftList, rightList)
}

func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
	if l1 == nil {
		return l2
	}
	if l2 == nil {
		return l1
	}
	if l1.Val < l2.Val {
		l1.Next = mergeTwoLists(l1.Next, l2)
		return l1
	} else {
		l2.Next = mergeTwoLists(l1, l2.Next)
		return l2
	}
}

func print(l *ListNode) {
	println(l.Val)
	if l.Next != nil {
		print(l.Next)
	}
}

func main() {
	// [[1,4,5],[1,3,4],[2,6]]
	l1 := &ListNode{
		Val: 1,
		Next: &ListNode{
			Val: 4,
			Next: &ListNode{
				Val:  5,
				Next: nil,
			},
		},
	}
	l2 := &ListNode{
		Val: 1,
		Next: &ListNode{
			Val: 3,
			Next: &ListNode{
				Val:  4,
				Next: nil,
			},
		},
	}
	l3 := &ListNode{
		Val: 2,
		Next: &ListNode{
			Val:  6,
			Next: nil,
		},
	}
	l4 := mergeKLists([]*ListNode{l1, l2, l3})
	print(l4)
}
```

В этом решении мы используем рекурсивный подход для объединения списков. Сначала мы разделяем список на две части и рекурсивно вызываем функцию `merge` для каждой части. Затем мы объединяем два списка с помощью функции `mergeTwoLists`, которая сравнивает значения первых элементов каждого списка и добавляет меньший элемент в новый список. Мы продолжаем этот процесс до тех пор, пока не объединим все списки в один.
