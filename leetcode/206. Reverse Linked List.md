Задача в том, чтобы развернуть связанный список. Например, если у нас есть список 1 -> 2 -> 3 -> 4, то после разворота он должен выглядеть как 4 -> 3 -> 2 -> 1.

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func reverseList(head *ListNode) *ListNode {
    var prev *ListNode
    curr := head
    for curr != nil {
        next := curr.Next
        curr.Next = prev
        prev = curr
        curr = next
    }
    return prev
}
```

В этом решении мы используем три указателя: `prev`, `curr` и `next`. Начинаем с `prev` равным `nil`, `curr` равным голове списка и `next` равным следующему элементу после `curr`.

Затем мы перебираем список, пока `curr` не станет равным `nil`. В каждой итерации мы сохраняем следующий элемент в `next`, затем меняем указатель `curr.Next` на `prev`, чтобы развернуть список. Затем мы перемещаем `prev` и `curr` на следующий элементы списка.

После того, как мы перебрали весь список, `prev` будет указывать на новую голову списка, поэтому мы возвращаем его.

---

А если исходный список не должен измениться?

Проблема заключается в том, что при возврате развернутого списка reverseList изменяет исходный список. Чтобы это исправить, нужно изменить reverseList, чтобы он создавал новый список и заполнял его значениями из исходного списка в обратном порядке.

```go
func reverseList(head *ListNode) *ListNode {
  var prev *ListNode
  curr := head
  for curr != nil {
    node := &ListNode{
      Val:  curr.Val,
      Next: prev,
    }
    prev = node
    curr = curr.Next
  }
  return prev
}
```
