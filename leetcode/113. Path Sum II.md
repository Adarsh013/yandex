Задача в том, чтобы найти все пути в бинарном дереве, которые дают сумму, равную заданному числу.

Алгоритм решения:

- Создать пустой список для хранения всех найденных путей.
- Написать рекурсивную функцию, которая принимает на вход текущий узел дерева, текущий путь и текущую сумму.
- Если текущий узел равен null, то выйти из функции.
- Добавить значение текущего узла к текущей сумме и добавить текущий узел в текущий путь.
- Если текущий узел является листом и текущая сумма равна заданному числу, то добавить текущий путь в список найденных путей.
- Рекурсивно вызвать функцию для левого и правого поддеревьев с текущим путем и суммой.
- Удалить последний элемент из текущего пути, чтобы вернуться к предыдущему узлу.

```go
type TreeNode struct {
    Val int
    Left *TreeNode
    Right *TreeNode
}

func pathSum(root *TreeNode, sum int) [][]int {
    paths := [][]int{}
    findPaths(root, []int{}, 0, sum, &paths)
    return paths
}

func findPaths(node *TreeNode, path []int, currSum int, sum int, paths *[][]int) {
    if node == nil {
        return
    }
    currSum += node.Val
    path = append(path, node.Val)
    if node.Left == nil && node.Right == nil && currSum == sum {
        *paths = append(*paths, path)
        return
    }
    findPaths(node.Left, append([]int{}, path...), currSum, sum, paths)
    findPaths(node.Right, append([]int{}, path...), currSum, sum, paths)
}
```

В данном коде мы создаем функцию `pathSum`, которая принимает на вход корень дерева и заданную сумму. Внутри функции мы создаем пустой список `paths` для хранения найденных путей и вызываем рекурсивную функцию `findPaths`.

Функция `findPaths` принимает на вход текущий узел `node`, текущий путь `path`, текущую сумму `currSum`, заданную сумму `sum` и указатель на список `paths`. Если текущий узел равен null, то функция завершается. Затем мы добавляем значение текущего узла к текущей сумме и добавляем текущий узел в текущий путь. Если текущий узел является листом и текущая сумма равна заданному числу, то мы добавляем текущий путь в список найденных путей. Затем мы рекурсивно вызываем функцию для левого и правого поддеревьев с текущим путем и суммой. Наконец, мы удаляем последний элемент из текущего пути, чтобы вернуться к предыдущему узлу.
