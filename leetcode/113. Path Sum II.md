Задача в том, чтобы найти все пути в бинарном дереве, которые дают сумму, равную заданному числу.

Алгоритм решения:

- Создать пустой список для хранения всех найденных путей.
- Написать рекурсивную функцию, которая принимает на вход текущий узел дерева, текущий путь и текущую сумму.
- Если текущий узел равен null, то выйти из функции.
- Добавить значение текущего узла к текущей сумме и добавить текущий узел в текущий путь.
- Если текущий узел является листом и текущая сумма равна заданному числу, то добавить текущий путь в список найденных путей.
- Рекурсивно вызвать функцию для левого и правого поддеревьев с текущим путём и суммой.- Удалить последний элемент из текущего пути, чтобы вернуться к предыдущему узлу.

```go
package main

import "fmt"

type TreeNode struct {
	Val   int
	Left  *TreeNode
	Right *TreeNode
}

func `pathSum`(root *TreeNode, sum int) [][]int {
	paths := [][]int{}
	`findPaths`(root, []int{}, 0, sum, &paths)
	return paths
}

func `findPaths`(node *TreeNode, path []int, currSum int, sum int, paths *[][]int) {
	if node == nil {
		return
	}
	currSum += node.Val
	path = append(path, node.Val)
	isLeaf := node.Left == nil && node.Right == nil
	if isLeaf && currSum == sum {
		*paths = append(*paths, path)
		return
	}
	`findPaths`(node.Left, append([]int{}, path...), currSum, sum, paths)
	`findPaths`(node.Right, append([]int{}, path...), currSum, sum, paths)
}

func main() {
	var root *TreeNode
	// Input: root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22
	// Output: [[5,4,11,2],[5,8,4,5]]
	// Explanation: There are two paths whose sum equals targetSum:
	// 5 + 4 + 11 + 2 = 22
	// 5 + 8 + 4 + 5 = 22
	root = &TreeNode{
		Val: 5,
		Left: &TreeNode{
			Val: 4,
			Left: &TreeNode{Val: 11,
				Left:  &TreeNode{Val: 7},
				Right: &TreeNode{Val: 2},
			},
		},
		Right: &TreeNode{
			Val:  8,
			Left: &TreeNode{Val: 13},
			Right: &TreeNode{Val: 4,
				Left:  &TreeNode{Val: 5},
				Right: &TreeNode{Val: 1},
			},
		},
	}
	fmt.Printf("%v\n", `pathSum`(root, 22))
	// Input: root = [1,2,3], targetSum = 5
	// Output: []
	root = &TreeNode{
		Val:   1,
		Left:  &TreeNode{Val: 2},
		Right: &TreeNode{Val: 3},
	}
	fmt.Printf("%v\n", `pathSum`(root, 5))
	// Input: root = [1,2], targetSum = 0
	// Output: []
	root = &TreeNode{
		Val:  1,
		Left: &TreeNode{Val: 2},
	}
	fmt.Printf("%v\n", `pathSum`(root, 0))
}
```

Функция `pathSum` использует функцию `findPaths` для обхода каждого узла дерева и поиска путей, сумма значений узлов которых равна целевой сумме.

Алгоритмическая сложность функции `findPaths` - это время, необходимое для обхода каждого узла дерева. Так как каждый узел дерева обрабатывается только один раз, то время работы функции зависит линейно от количества узлов в дереве.

Поэтому, если в дереве n узлов, то алгоритмическая сложность функции `findPaths` будет O(n).

Функция `pathSum` вызывает функцию `findPaths` для каждого узла дерева, поэтому алгоритмическая сложность функции `pathSum` будет O(n^2), где n - количество узлов в дереве.
