Задача в том, чтобы найти все анаграммы заданной строки `p` в строке `s` и вернуть их индексы в `s`.

Для решения этой задачи мы можем использовать подход с использованием словаря (map) и двух указателей (pointers).

```go
package main

import (
	"fmt"
)

func findAnagrams(s string, p string) []int {
	result := []int{}
	pCount := make(map[byte]int)
	for _, ch := range p {
		pCount[byte(ch)]++
	}
	left, right, count := 0, 0, len(p)
	for right < len(s) {
		if pCount[s[right]] > 0 {
			count--
			if count == 0 {
				result = append(result, left)
			}
		}
		pCount[s[right]]--
		right++
		if right-left == len(p) {
			pCount[s[left]]++
			if pCount[s[left]] > 0 {
				count++
			}
			left++
		}
	}
	return result
}

func main() {
	var s, p string
	// Input: s = "cbaebabacd", p = "abc"
	// Output: [0,6]
	// Explanation:
	// The substring with start index = 0 is "cba", which is an anagram of "abc".
	// The substring with start index = 6 is "bac", which is an anagram of "abc".
	s = "cbaebabacd"
	p = "abc"
	fmt.Println(findAnagrams(s, p))
	// Input: s = "abab", p = "ab"
	// Output: [0,1,2]
	// Explanation:
	// The substring with start index = 0 is "ab", which is an anagram of "ab".
	// The substring with start index = 1 is "ba", which is an anagram of "ab".
	// The substring with start index = 2 is "ab", which is an anagram of "ab".
	s = "abab"
	p = "ab"
	fmt.Println(findAnagrams(s, p))
}
```

Сначала мы создадим словарь, который будет содержать количество каждого символа в строке `p`. Затем мы будем использовать два указателя, `left` и `right`, чтобы пройти по строке `s`. Мы будем увеличивать `right`, пока не найдем подстроку, которая содержит все символы из словаря. Затем мы будем увеличивать `left`, пока не найдем подстроку, которая содержит только символы из словаря. Если длина этой подстроки равна длине `p`, мы добавляем индекс `left` в результат.

Алгоритмическая сложность функции `findAnagrams()` - `O(n)`, где `n` - длина строки `s`.

---

Задача на "sliding window" - это техника алгоритма, которая заключается в выборе непрерывного подмножества элементов из последовательности. Этот подмассив имеет фиксированную длину (обычно равную размеру окна) и "скользит" по последовательности на каждой итерации, проверяя свойства других элементов внутри окна. Эта техника часто используется для решения задач, связанных с массивами и строками.
