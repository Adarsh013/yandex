Задача в том, чтобы найти максимальный элемент в каждом окне фиксированного размера, которое скользит по массиву целых чисел.

Например, если дан массив [1,3,-1,-3,5,3,6,7] и размер окна равен 3, то результатом будет массив [3,3,5,5,6,7], где каждый элемент - максимальный в своем окне.

Алгоритм решения:

- Создаем пустой слайс res для хранения максимальных значений в каждом окне.
- Создаем пустой дек (двустороннюю очередь) q для хранения индексов элементов в текущем окне.
- Проходим по массиву nums и для каждого элемента i:
- Удаляем из дека q все индексы, которые находятся за пределами текущего окна (т.е. индексы, которые меньше i-k+1).
- Удаляем из дека q все индексы, которые соответствуют элементам, меньшим или равным nums[i].
- Добавляем индекс i в конец дека q.
- Если индекс первого элемента в деке q находится за пределами текущего окна, то удаляем его.
- Если текущий индекс i больше или равен k-1 (т.е. окно уже полностью заполнено), то добавляем максимальный элемент (nums[q[0]]) в слайс res.
- Возвращаем слайс res.

```go
func maxSlidingWindow(nums []int, k int) []int {
    n := len(nums)
    if n == 0 {
        return []int{}
    }
    res := make([]int, 0, n-k+1)
    q := make([]int, 0, k)
    for i := 0; i < n; i++ {
        // remove indexes out of current window
        for len(q) > 0 && q[0] < i-k+1 {
            q = q[1:]
        }
        // remove indexes of elements smaller than nums[i]
        for len(q) > 0 && nums[q[len(q)-1]] <= nums[i] {
            q = q[:len(q)-1]
        }
        q = append(q, i)
        // remove index of first element if it's out of current window
        if i >= k-1 {
            res = append(res, nums[q[0]])
        }
    }
    return res
}
```
