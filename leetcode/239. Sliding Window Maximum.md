Задача в том, чтобы найти максимальный элемент в каждом окне фиксированного размера, которое скользит по массиву целых чисел.

Например, если дан массив [1,3,-1,-3,5,3,6,7] и размер окна равен 3, то результатом будет массив [3,3,5,5,6,7], где каждый элемент - максимальный в своём окне.

- [пример решения в картинках](https://leetcode.com/problems/sliding-window-maximum/solutions/871317/clear-thinking-process-with-picture-brute-force-to-mono-deque-python-java-javascript/)

Алгоритм решения:

- Создаем пустой слайс `res` для хранения максимальных значений в каждом окне.
- Создаем пустой дек (двустороннюю очередь) q для хранения индексов элементов в текущем окне.
- Проходим по массиву nums и для каждого элемента i:
- Удаляем из дека q все индексы, которые находятся за пределами текущего окна (т.е. индексы, которые меньше i-k+1).
- Удаляем из дека q все индексы, которые соответствуют элементам, меньшим или равным nums[i].
- Добавляем индекс i в конец дека q.
- Если индекс первого элемента в деке q находится за пределами текущего окна, то удаляем его. (?)
- Если текущий индекс i больше или равен k-1 (т.е. окно уже полностью заполнено), то добавляем максимальный элемент (nums[q[0]]) в слайс res.
- Возвращаем слайс res.

```go
package main

import "fmt"

func maxSlidingWindow(nums []int, k int) []int {
    n := len(nums)
    res := make([]int, 0, n-k+1) // Результирующий массив
    q := make([]int, 0, k) // Очередь, хранящая индексы элементов
    // Проходим по всем элементам массива
    for i := 0; i < n; i++ {
        // Удаляем индексы элементов, которые находятся за пределами текущего окна
        for len(q) > 0 && q[0] < i-k+1 {
            q = q[1:]
        }
        // Удаляем индексы элементов, которые имеют значения меньшие, чем текущий элемент
        for len(q) > 0 && nums[q[len(q)-1]] <= nums[i] {
            q = q[:len(q)-1]
        }
        // Добавляем индекс текущего элемента в очередь
        q = append(q, i)
        // Если текущее окно полностью находится в массиве, то добавляем максимальный элемент в результирующий массив
        if i >= k-1 {
            res = append(res, nums[q[0]])
        }
    }
    return res
}

func main() {
	var nums []int
	// Input: nums = [1,3,-1,-3,5,3,6,7], k = 3
	// Output: [3,3,5,5,6,7]
	// Explanation:
	// Window position                Max  -> Queue
	// ---------------               -----
	// [1  3  -1] -3  5  3  6  7       3   -> 3 -1
	//  1 [3  -1  -3] 5  3  6  7       3   -> 3 -1 -3
	//  1  3 [-1  -3  5] 3  6  7       5   -> 5
	//  1  3  -1 [-3  5  3] 6  7       5   -> 5 3
	//  1  3  -1  -3 [5  3  6] 7       6   -> 6
	//  1  3  -1  -3  5 [3  6  7]      7   -> 7
	nums = []int{1, 3, -1, -3, 5, 3, 6, 7}
	fmt.Printf("%v\n", maxSlidingWindow(nums, 3))
	// Input: nums = [1], k = 1
	// Output: [1]
	nums = []int{1}
	fmt.Printf("%v\n", maxSlidingWindow(nums, 1))
}
```

Алгоритмическая сложность функции `maxSlidingWindow()` - `O(n)`, где `n` - длина массива `nums`, а `k` - размер окна.

---

Функция `maxSlidingWindow` решает задачу нахождения максимального элемента в каждом окне длины `k` в массиве `nums`.

```go
package main

import "fmt"

func maxSlidingWindow(nums []int, k int) []int {
	result := make([]int, len(nums)-(k-1))
	queue := make([]int, 0, len(nums)-(k-1))
	for i, n := range nums {
		for len(queue) != 0 && n > nums[queue[len(queue)-1]] {
			queue = queue[:len(queue)-1]
		}
		queue = append(queue, i)
		if i >= k-1 {
			result[i-(k-1)] = nums[queue[0]]
			if queue[0] == i-(k-1) {
				queue = queue[1:]
			}
		}
	}
	return result
}

func main() {
	var nums []int
	// Input: nums = [1,3,-1,-3,5,3,6,7], k = 3
	// Output: [3,3,5,5,6,7]
	// Explanation:
	// Window position                Max  -> Queue
	// ---------------               -----
	// [1  3  -1] -3  5  3  6  7       3   -> 3 -1
	//  1 [3  -1  -3] 5  3  6  7       3   -> 3 -1 -3
	//  1  3 [-1  -3  5] 3  6  7       5   -> 5
	//  1  3  -1 [-3  5  3] 6  7       5   -> 5 3
	//  1  3  -1  -3 [5  3  6] 7       6   -> 6
	//  1  3  -1  -3  5 [3  6  7]      7   -> 7
	nums = []int{1, 3, -1, -3, 5, 3, 6, 7}
	fmt.Printf("%v\n", maxSlidingWindow(nums, 3))
	// Input: nums = [1], k = 1
	// Output: [1]
	nums = []int{1}
	fmt.Printf("%v\n", maxSlidingWindow(nums, 1))
}
```

Алгоритм использует одну очередь `queue`, которая содержит индексы элементов в текущем окне. Очередь `queue` хранит индексы элементов в порядке убывания их значений. Таким образом, первый элемент очереди всегда будет максимальным элементом в текущем окне.

Алгоритм проходит по всем элементам массива `nums`. Для каждого элемента `n` алгоритм удаляет из очереди все индексы элементов, которые находятся за пределами текущего окна, и которые, соответственно, не могут быть максимальными элементами в текущем окне. Затем алгоритм удаляет из очереди все индексы элементов, которые имеют значения меньшие, чем текущий элемент `n`, так как эти элементы не могут быть максимальными в текущем окне.

После того, как элемент `n` добавлен в очередь `queue`, алгоритм проверяет, находится ли первый элемент очереди `queue[0]` в текущем окне. Если да, то `queue[0]` является максимальным элементом в окне, и алгоритм добавляет его значение в массив `result`. Если `queue[0]` находится за пределами текущего окна, то алгоритм удаляет `queue[0]` из очереди, так как это значение больше не может быть максимальным в следующих окнах.

В конце алгоритм возвращает массив `result`, содержащий максимальные элементы в каждом окне длины `k`. Алгоритм имеет сложность `O(n)`, где `n` - длина массива `nums`.

---

Или через абстракцию:

```go
package main

import (
	"fmt"
)

type Deque []int

func NewDeque(capacity int) *Deque {
	d := make(Deque, 0, capacity)
	return &d
}

func (d Deque) Len() int         { return len(d) }
func (d Deque) Front() int       { return d[0] }
func (d Deque) Back() int        { return d[len(d)-1] }
func (d *Deque) PushFront(x int) { *d = append([]int{x}, (*d)...) }
func (d *Deque) PushBack(x int)  { *d = append(*d, x) }
func (d *Deque) RemoveFront()    { *d = (*d)[1:] }
func (d *Deque) RemoveBack()     { *d = (*d)[:len(*d)-1] }

func maxSlidingWindow(nums []int, k int) []int {
	ln := len(nums) - (k - 1)
	result := make([]int, ln)
	d := NewDeque(ln)
	for r, num := range nums {
		for d.Len() > 0 && nums[d.Back()] < num {
			d.RemoveBack()
		}
		d.PushBack(r)
		if r >= k-1 {
			l := r - (k - 1)
			result[l] = nums[d.Front()]
			if d.Front() == l {
				d.RemoveFront()
			}
		}
	}
	return result
}

func main() {
	var nums []int
	// Input: nums = [1,3,-1,-3,5,3,6,7], k = 3
	// Output: [3,3,5,5,6,7]
	// Explanation:
	// Window position                Max  -> Queue
	// ---------------               -----
	// [1  3  -1] -3  5  3  6  7       3   -> 3 -1
	//  1 [3  -1  -3] 5  3  6  7       3   -> 3 -1 -3
	//  1  3 [-1  -3  5] 3  6  7       5   -> 5
	//  1  3  -1 [-3  5  3] 6  7       5   -> 5 3
	//  1  3  -1  -3 [5  3  6] 7       6   -> 6
	//  1  3  -1  -3  5 [3  6  7]      7   -> 7
	nums = []int{1, 3, -1, -3, 5, 3, 6, 7}
	fmt.Printf("%v\n", maxSlidingWindow(nums, 3))
	// Input: nums = [1], k = 1
	// Output: [1]
	nums = []int{1}
	fmt.Printf("%v\n", maxSlidingWindow(nums, 1))
}
```
