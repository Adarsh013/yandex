```go
// var o struct{} - инициализирует структуру o
// var a [3]int - инициализирует массив a
// var v []int - объявляет nil-слайс v
// var m map[string]int - объявляет nil-карту m
// var ch chan string - объявляет nil-канал ch
// if i := 0; i == 0 {} - присваивание; условие
// switch t := v.(type) - .(type) работает только внутри switch
// fallthrough - переход в следующий case (без его проверки), или в default
// a := [5]any{"1", 2, true}
// l := t[:] - не меняет unsafe.Pointer
// l := t[1:2:3] - третий член определяет ёмкость
// cap() - для массивов, как алиас на len()
// cap() - применим для слайсов и каналов
// for i, ch := range s {} "go" - ch имеет тип rune, s имеет тип string (т.е. range итерирует строку рунами); но i возвращает не индекс руны, а начальный индекс руны в []byte(s)
// for i, r := range []rune(s) {} - тогда i возвращает индекс руны; но сложность O(n), где n — количество байтов в строке
// ch := make(chan string) - блокирует передатчик, пока не готов приёмник
// bufferedCh := make(chan string, 1) - неблокирует передатчик, пока не готов приёмник
// make(<-chan bool) / make(chan<- bool) - ответ на вопрос: зачем создавать каналы только для чтения / записи? и ещё: канал только на чтение невозможно закрыть!
// j, ok := <-jobs - проверка, что канал закрыт
// for t := range ticker.C {} - чтение из канала ticker.C
// wg.Add(1) запускать в том же потоке, где и wg.Wait()
// time.Tick() - лучше не использовать, it "leaks"; вместо него NewTicker() + Stop()
// myType(val) - приведение типа работает, если известен тип для val
// val.(myType) - утверждение типа работает, если тип для val неопределён (т.е. interface{})
// var i int; defer func(i int) { println(i) }(i); i = 1 - выведет 0
// var i int; defer func(i *int) { println(*i) }(&i); i = 1 - выведет 1
// var i int; defer func() { println(i) }(); i = 1 - выведет 1
// func test() (x int) { defer func() { x++ }(); x = 1; return } - выведет 2
// есть ли в стандартной библиотеке пакет для работы с коллекциями разных типов через дженерики?
// [Лучший regexp для Go](https://habr.com/ru/articles/756222/)
// regexp.MustCompile() для глобальных переменных вместо regexp.Compile()
// type MyType struct { Page int `json:"page"` } - поле публичное (с большой буквы) + "json-тег структуры"
// diff := time.Now().Sub(other) - разница между двумя временами
// time.Now().Add(-diff) - продвинуть время на заданную продолжительность
// u, _ := url.Parse(s); net.SplitHostPort(u.Host) - как вытащить порт
// ew := &errWriter{Writer: w} - где errWriter реализует свой метод Write с предварительной обработкой сохранённой ошибки https://habr.com/ru/articles/759920/
// os.RemoveAll("dir") - аналог "rm -rf"
// go test -v - флаг -v отображает прохождение тестов
// go test -run="VectorA.*$|TestVectorMag" -v - применение regex для фильтра тестов
// [fuzzing-тесты](https://habr.com/ru/companies/oleg-bunin/articles/709248/)
// testify - в помощь по тестированию к стандартной библиотеке
// mockery - для тестов
// [migrate](https://github.com/golang-migrate/migrate)
// flag - стандартный пакет, плюс выбор: flaggy 840 | go-flags 2500 | pflag 2200
// exec.Command("bash", "-c", "ls -a -l -h") - как создать полную команду в одну строку вместо exec.Command("ls", "-a", "-l", "-h")
// os.Exit(1) - игнорирует defer
// цветные логи: https://github.com/GolangLessons/url-shortener/blob/c3987f66469a8d0769add18521adb9023520be95/internal/lib/logger/handlers/slogpretty/slogpretty.go
// vegeta, wrk - для стресс-тестов
// когда нужен сервер httpserver - https://github.com/evrone/go-clean-template/tree/master/pkg/httpserver
// allegro/bigcache - когда нужен просто кеш (рекомендации лучших собаководов из Avito)
// go-playground/validator - правильный валидатор
// func New(ctx context.Context, connectionString string, opts ...Option) (*Storage, error) - паттерн опций для конструктора в функциях
// tdlibClient.GetMessage(&client.GetMessageRequest{}) паттерн опций для методов в структуре
// благодатное выключение - Graceful Shutdown
// func New() или func NewSubscriber() для пакета subscriber ? нет, например: errors.New
// signal.Notify(interrupt, syscall.SIGINT, syscall.SIGTERM) - неправильно, signal.Notify(interrupt, os.Interrupt, syscall.SIGTERM) - правильно. os.Interrupt == syscall.SIGINT
// "божественный конфиг" - https://youtu.be/0Fhsgmz-Gig?list=PLZvfMc-lVSSO2zhyyxQLFmio8NxvQqZoN&t=906
// ilyakaznacheev/cleanenv - yaml & env в одном флаконе + godotenv для чтения .env
// если функция кидает панику, то у неё должен быть префикс Must*, например MustLoad()
// TEST EXPLORER внутри VS Code
// jackc/pgx/v5/pgxpool / go-pg + pool - PG Pool
// Masterminds/squirrel - SQL Builder (by Avito)
// [Dependency Injection](https://youtu.be/0Fhsgmz-Gig?list=PLZvfMc-lVSSO2zhyyxQLFmio8NxvQqZoN&t=1001)
// [Dependency Injection на примере Uber fx](https://www.youtube.com/watch?v=KRdrH9a98HQ)
// [Learn Go with Tests - Dependency Injection](https://quii.gitbook.io/learn-go-with-tests/go-fundamentals/dependency-injection)
// внутри interface ненужно прописывать ключевое слово func
// type Number interface { ~int | ~int8 } - тип для дженериков: func Fn[T Number](a T) {}; "~" нужна для наследников int, например: type MyInt int
// er := errgroup.Group{}; eg.SetLimit(limit) - ещё один примитив синхронизации (golang.org/x/sync/errgroup)
// math.Pow() - возведение в степень
// механизм эвакуации в map
// RWMutex - читаем без блокировок на чтение, но с блокировкой на запись при чтении(!), или записи
// map в Go не гарантирует порядок ключей, ES6 - гарантирует, а Dart - нет (hash map vs b-tree map); reflect.DeepEqual() при перестановке ключей-значений вернёт true для map, но false - для слайсов/массивов (т.к. там порядок членов гарантирован).
// log.Fatal(http.ListenAndServe(":8080", httpserver.NewHandler())) - как вариант обработки ошибок
// "божественный" main.go
// string - это тоже структура и лежит в куче; при передаче аргументом, что копируется?
// func (Bear) Speak() - можно не указывать "this" в рессивере при реализации метода структуры
// Интерфейсы - способ, как сделать программу SOLIDной? (Dependency Inversion)
// где лучше объявлять интерфейсы: где применяются или где реализуются?
// type (A struct {}; B struct {}) - типы можно объявлять группой
// go run . | ts '%.Ss' - не работает с println(), только с fmt.Println()
// gherkingen - для BDD
// пакеты и папки - вместо пробелов применяется тире, а файлы - подчёркивания
// go test - это интерпретатор, а значит реализуем функционал, подобный WallabyJS
// что не нравится в Go? имплементация методов интерфейса в отрыве от объявления интерфейса, т.е. отсутствует самодокументирование кода, как например в Dart: class MyClass implements MyInterface {}
// что не нравиться в go? импорт без алиасов (как было в TypeScript), таскание контекста первым аргументом в функциях, отсутствует интерполяция строк
// что не нравится в Go? Горутина — это такой же ресурс, как и любой другой, который должен быть закрыт для освобождения памяти или других ресурсов. При этом нет какого-либо идеоматичного решения, типа defer для освобождения ресурсов.
// try MyClass { lock sync.Mutex } - ненужно инициализировать, тут работает "ленивая инициализация"
// arr := [...]int{5: 0} - что лежит в arr?
// break внутри case в select / switch - выйдут из области видимости select / switch (а не прервут for)
// повторить Go Cuncurrency Patterns https://github.com/Konstantin8105/Go-pipelines
// повторить Go Cuncurrency Patterns https://habr.com/ru/companies/otus/articles/722880/
// вкурить: quicksort, mergesort, heapsort, сортировка вставками и пузырковая сортировка
// type Counter struct { data  chan int } - когда объявляем канал, не обозначить буферизированный он, или нет (т.к. буферезация - часть инстанса)
// type MyType struct { k1 int, k2 int } - можно инициализировать не все именованные поля, например: v := MyType{k1:0}; v := MyType{k2:0}
// for range done {} вместо <-done
// научиться готовить новый пакет slices (v1.21)
// как получить доступ на внутренний массив слайса? *(*[3]int)(unsafe.Pointer(&a[0]))
// [Understanding Real-World Concurrency Bugs in Go](https://songlh.github.io/paper/go-study.pdf) [Как не ошибиться с конкурентностью в Go](https://www.youtube.com/watch?v=4U3EaVufuW4)
// runtime.Gosched() - команда шедулеру для вытеснения (preemptible) текущей горутины
// interval := 0 * time.Second - идиома?
// GetWorkDir() - ex := os.Executable() >> dir := filepath.Dir(ex) >> strings.Contains(dir, "go-build") - как способ узнать: go build / go run
// time.AfterFunc - возможность вызвать callback
// go увеличивает capacity только при append, но не на обрезаниях
// a := []int{1, 2}; a = append(a, []int{3, 4, 5}...); println(cap(a)) // 6 - прибавляет всегда чётное число, равное len(a) или больше на 1. Фокус, когда добавляемых элементов больше, чем размер исходного слайса. При этом финальный размер должен быть больше либо равен 5. Ответ: alignUp rounds n up to a multiple of a. a must be a power of 2. Дополнительно: https://habr.com/ru/articles/660827/
// for n := range ch {} - классическая ошибка - забыть закрыть канал, тогда будет блокировка типа <-done без пары записи в канал
// префикс must обычно используется в функциях, которые могут вызвать панику
// для модульных/интеграционных-тестов package не менять (иначе, только ради тестов открываю все внутренности в API модуля - это неправильно, только добавляет когнитивную нагрузку в Developer Experience), а для приёмочных выносить в отдельный package с суффиксом _test, что заставляет определить API модуля.
// io.Discard - заглушка для io.Writer
// var _ MyInterface = (*MyStruct)(nil) - как с помощью типизированного nil можно проверить, что тип структуры реализует интерфейс, не создавая инстанс этой структуры
// [Compile-time Dependency Injection for Go](https://github.com/google/wire)
// [Fx is a dependency injection system for Go](https://github.com/uber-go/fx)
// https://github.com/uber-go/zap
// https://github.com/golangci/golangci-lint
// https://github.com/uber-go/config
// https://github.com/go-telegram-bot-api/telegram-bot-api
// вызов r.Context() внутри обработчика для http.NewServeMux()
// sync.TryLock
// slices.Clip - имеет смысл пробовать после 10Мб https://www.youtube.com/watch?v=G-lhh_1XNcI
// type parameters VS generics - зачем два термина? Таким образом, “type parameters” и “generics” относятся к различным аспектам одной и той же функциональности. “Generics” относится к общей концепции написания кода, который может работать с различными типами, в то время как “type parameters” относится к конкретному механизму, используемому для реализации этой функциональности.
// `func F[T ~int](i T) {}` - approximation element, допускает `int` и `type MyInt int` (требуемый базовый тип)
// как запомнить Itoa & Atoi из пакета strconv: i_to_a & a_to_i
// type M[T any] []T - дженерик для слайса, определяемый параметром типа
// почему параметры типа в Go обозначают в квадратных скобочках, а не в треугольных, как в других языках?
// А можно сказать, что "approximation element" для параметров типа в дженериках - это LSP из SOLID?
// x, y = "1", 2 - называется "присваивание кортежу"
// UTF-8 - принятая кодировка в Go (авторы Ken Thompson и Rob Pike), которая описывает рунами символы из unicode.org, где каждая руна может иметь разную длину от одного до четырех байтов, в отличии от кодировки UTF-32 (фиксированный размер int32), и UTF-16 - это кодировка фиксированной длины, которая использует два или четыре байта. но `rune // alias for int32`
// генератор констант iota
// нетипизированные константы
// type MyInt int - "именованный тип", может применяться "анономным полем" через механизм "embedded": type MyObj struct { MyInt }; println(MyObj{1}.MyInt)
// type Event struct {ID int; time.Time}; event := Event{ID: 1234, Time: time.Now()} - инициализация "анонимного поля"
// type MyType struct {}; func (a *MyType) Try() { if a == nil { println("nil") } }; var a *MyType; a.Try(); - подобие статического метода класса
// type MyType struct{}; func (a *MyType) Try() {}; var a *MyType; try := (*MyType).Try; try(a); - выражение-метод, работает и с (*MyType).Try и с MyType.Try в зависимости от того, как передаётся рессивер ("значение-метод" - это метод в переменной от инстанса, "выражение-метод" - это метод в переменной от типа)
// var _ io.Writer = (*bytes.Buffer)(nil) - проверка без создания экзепляра, что *bytes.Buffer реализует интерфейс io.Writer
// Методы, определенные для типа T, также доступны для указателей этого типа (*T). Однако обратное не верно: методы, определенные для *T, не доступны для T.
// интерфейсный тип не даёт типизированный nil: var w io.Writer = nil // <nil> VS var w *os.File = nil // (*os.File)(nil)
// func fn(out io.Writer) { if out != nil { ... } } - потенциальная ошибка, если передать типизированный nil, например var buf *bytes.Buffer
// var x any = []int{1, 2, 3}; println(x == x) - какой линтер может отлавливать эту ситуацию? Сравнивайте значения интерфейсов, только если вы уверены, что они содержат динамические значения сравниваемых типов.
// type Interface interface - "базовый" интерфейс модуля называется Interface (например: sort.Interface)
// rw := w.(io.ReadWriter) - panic: interface conversion; rw, ok := w.(io.ReadWriter) - ok == false
// io.WriteString - это рекомендованный способ записи строки в io.Writer
// switch x := x.(type) { case nil: return "NULL" } - при выборе типа можно проверять на nil; в выборе типа применение fallthrough не разрешено
// switch без условия полезен тем, что может использоваться для проверки нескольких условий
// fallthrough внутри switch "проваливает" выполнение в следующий блок case без проверки условия в этом case
// switch без условий эквивалентен switch true, т.е. switch { case true: println("OK") }
// при чтении для канала можно использовать `value, ok := <-ch`
// https://github.com/mcfly722/context
// func fn(x, y int) int - сигнатура функции (для Go - вместе с возвращаемым типом)
// fn := func(x, y int) int { return x * y } - то, что присваивается fn, называется "литералом функции"
// `const dog = { name: 'Naya', sex: 'female', age: 2, breed: 'Rottweiler mix' };` - объектный литерал в JavaScript; по аналогии в GoLang есть понятия "литерал структуры" и "литерал карты". В компьютерных науках литерал - это текстовое представление значения, так как оно записано в исходном коде. a := 1; // 1 - это целочисленный литерал s := "cat"; // "cat" - это строковый литерал
// у каждого пакета должна быть своя отдельная директория
// Python также поддерживает возврат нескольких значений из функции, подобно Go
// guard clauses - "защитные оговорки", это когда в теле функции сначала проверяю условия и выхожу при их обнаружении, а только потом вычисляю основной вариант (вместо вложенного ветвления if-ов).
// myCar := struct{ make, model string }{"tesla", "model3"} - анонимная структура; может применяться для вложенности структур
// sum(nums ...int) - вариативная функция (variadic function), где nums - слайс, ... - spread operator; sum(nums...) - при вызове тоже можно использовать ... - slice unpacking
// каналы можно в мапы в качестве ключей, т.к. это сравниваемый тип
// как получить руну в строке по индексу: `s := "👻abc"; runes := []rune(s); println(string(runes[1]))`
// `var a *int; b := *a` - разименование nil-указателя приведёт к panic
// `go build` в директории локального пакета выполнит кеширование для дальнейшей сборки модуля
// `go install` выполнит сборку и установку модуля локально в системе в `GOPATH`, хотя всё остальное про `GOPATH` - устарело
// replace внутри go.mod: `replace example.com/username/module v0.0.0 => ../module` (альтернатива `go work init` начиная с go1.18)
// для модулей go не нужен какой-то внешний реестр модулей (как npm в javascript, например)
// закрытие канала приводит к широковещательному оповещению всех слушателей (в отличии от передачи данных по каналу - "кто первый встал, того и тапки"); но следует учитывать, что при закрытии буферизованного канала, сначала будут прочитаты все оставшиеся значения.
// sync.Cond тоже умеет в широковещательное оповещение всех слушателей - .Broadcast()
// `v, ok := <-ch` - ok сообщает, получилось ли прочитать из канала (а не "канал открыт/закрыт"); только когда в (закрытом) буферизованном канале не осталось значений: v == 0, ok == false
// `for v, ok := range ch {}` - ok для каналов не имеет смысла (не компилируется), а тут работает: `select { case v, ok := <-ch: }`
// порядок case-элементов в select не имеет значения (равномерный псевдослучайный выбор)
// функции init в одном пакете отрабатывают в порядке названий файлов пакета
// в большинстве случаев возвращать (из функции/метода) лучше не интерфейсы, а конкретные реализации (error - исключение); и наоборот, функции должны принимать интерфейсы всегда, когда это возможно. (а если возвращать интерфейс, то по указателю)
// var i *int - не инициализирует числовое значение, как 0.
// sum := 100 + 010 // 108 - целочисленный литерал, начинающийся с 0, считается восьмеричным целым числом; чтобы улучшить читаемость и избежать потенциальных ошибок, сделайте восьмеричные числа явными, используя префикс 0o
// можно использовать символ подчеркивания (_) в качестве раздели- теля для удобства чтения; например, записать 1 миллиард так: 1_000_000_000.
// var l, r int; mid := int(uint(l+r) / 2) - борьба с переполнением: https://www.bugsnag.com/blog/bug-day-ariane-5-disaster/
// `var a []int; b := append(a, 1)` или `b := append([]int(nil), 1)` - append работает с nil-срезом
// пустоту среза/карты всегда следует проверять через len(), чтобы избежать разницу между пустым и нулевым срезом/картой
// если мы хотим выполнить полное копирование через copy(), второй срез должен иметь длину больше или равную длине исходного
// `s1 := []int{1, 2, 3}; s2 := s1[1:2]; s3 := append(s2, 10)` побочный эффект: `s1=[1 2 10], s2=[2], s3=[2 10]`; как этого избежать: `s2 := s1[1:2:2]`
// В качестве эмпирического правила запомните, что нарезка большого среза или массива может потенциально привести к высокому потреблению памяти. Остающееся в памяти пространство не будет восстановлено сборщиком мусора, и мы можем сохранять в памяти очень большой резервный массив, несмотря на использование только нескольких элементов. Использование копии среза — это способ предотвращения такой ситуации.
// make для map задаёт только начальный размер, make для slice - начальный размер и ёмкость
// операция умножения не имеет приоритета над операцией деления, т.е. нужны скобки: b/(1024*1024)
// `m := make(map[int][129]byte)` Если ключ или значение превышает 128 байт, Go не будет хранить их непосредственно в сегменте карты. Вместо этого хранится указатель — для ссылки на ключ или на значение. Если меньше 128 байт, то лучше применять указатель: `m := make(map[int]*[128]byte)` (ошибка #28)
// как сравниваются каналы на == или !=: были ли два канала созданы одним и тем же вызовом функции make либо равны ли оба канала nil
// как сравниваются интерфейсы на == или !=: имеют ли два интерфейса одинаковые динамические типы и одинаковые динамические значения либо равны ли оба интерфейса nil
// `c := make(chan int, 1); close(c); select { case c<-1: }` - select может попытаться записать в закрытый канал, что приведёт к panic; т.е. тут недостаточно закрыть канал, нужно его сбросить в nil (c = nil)
// приоритизация в select: https://stackoverflow.com/questions/11117382/priority-in-go-select-statement-workaround
// `for i, v := range &a { a[i] = 1; print(v) }` - range принимает указатель на массив, чтобы увидеть изменения v (вместо print(a[i]))
// Если запись карты создается во время итерации, она может быть произведена во время итерации или пропущена. Выбор может варьироваться для каждой созданной записи и от одной итерации к другой.
// break loop VS goto next; `loop:` перед for: `loop:for{switch{case true: break loop}}` или `next:` после for: `for{switch{case true: goto next}}next:`
// Важное правило, о котором следует помнить, заключается в том, что оператор break завершает выполнение самого последнего оператора for, switch или select.
// continue тоже можно использовать с меткой
// символ: 汉; кодовая точка unicode (или rune): U+6C49; кодирование тремя байтами в UTF-8: 0xE6, 0xB1, 0x89
// format 'verbs' (спецификаторы формата) https://pkg.go.dev/fmt
// не путать TrimLeft/TrimRight VS TrimPrefix/TrimSuffix (из пакета strings)
// для конкаценации строк в циклах (более 5 строк) лучше использовать strings.Builder и его методы: .WriteString, .Write, .WriteByte, .WriteRune, .Grow (будущая длина среза / capacity)
// Нельзя сравнивать []int{1,2,3} == []int{1,2,3}, в отличии от [3]int{1,2,3} == [3]int{1,2,3}
// uuid := strings.Clone(log[:36]) - копирование строки для предотвращения утечки памяти
// именованные параметры результата метода в интерфейсе совместимы с безимянной реализацией
// не используй имя файла в качестве входных данных функции, вместо этого применяй абстракцию io.Reader
// Вызов функции recover() для перехвата паники горутины полезен только внутри функции defer; в противном случае функция просто вернет nil и более ни на что не будет влиять.
// `return fmt.Errorf("bar failed: %w", err)` - оборачивание ошибки, обратная операция `errors.Unwrap`
// Сигнальная ошибка (sentinel error) — это ошибка, определенная как глобальная переменная: `var ErrFoo = errors.New("foo")`. Понятие "ожидаемая ошибка" (например: io.EOF, sql.ErrNoRows) реализуется в виде значений (сигнальных ошибок); против понятия "непредвиденная ошибка" - реализуется в виде `type BarError struct { ... }`, где BarError реализует интерфейс error.
// если вы уверены, что ошибку можно и нужно игнорировать, то делайте это явно, присвоив ее пустому идентификатору. `_ = notify()` где `func notify() error`
// как передать err из defer в вызывающую функцию выше? через именованный параметр результата: `func fn() (err error) { defer func() { err = errors.New("error!") }() return }`
// Конкурентность — это о работе с большим количеством вещей одновременно. Параллелизм — это о выполнении множества дел одновременно. Роб Пайк
// Каналы — оркестрируют (конкурентные горутины), мьютексы — сериализируют (параллельные горутины)
// канал — это механизм для передачи сигналов с данными или без них; управляющий канал, или канал уведомлений (notification channel) - это канал без данных (struct{}{})
// atomic.LoadInt64() & atomic.StoreInt64() & type atomic.Value
// mutex - образовано от "mutual exclusion"
// преобразование типов не является атомарной операцией в контексте гонок данных
// Гонка данных происходит, когда несколько горутин одновременно обращаются к одной и той же ячейке памяти (например, к одной и той же переменной) и по крайней мере одна из горутин выполняет запись. Важно понимать, что отсутствие гонки данных необязательно будет выдавать детермирнированный результат (состояние гонки - отдельное понятие).
// Функция runtime.GOMAXPROCS() в Go устанавливает максимальное количество CPU, которые могут одновременно выполнять код на уровне пользователя. Однако это не строгое ограничение. Если горутина блокируется (например, системным вызовом), может быть запущен новый поток. Таким образом, даже если GOMAXPROCS установлен в 1, горутины все равно могут работать параллельно, если они блокируются. Стоит отметить, что по умолчанию GOMAXPROCS устанавливается равным количеству доступных логических процессоров. Установка его выше, чем количество доступных процессоров, может привести к большему количеству переключений контекста, если есть больше активных потоков, чем ядер.
// Лучшей практикой при обработке контекстных ключей будет создание неэкспортируемого пользовательского типа: `type key string; const myCustomKey key = "key"; ctx := context.WithValue(context.Background(), myCustomKey, "val")`
// Если вы сомневаетесь, какой контекст использовать, выбирайте context.TODO() вместо передачи пустого контекста с помощью context.Background()
// данные из контекста обычно вытаскивают в middleware - сначала делаем next.ServeHTTP(w, r), потом пишем в кафку
// signal.NotifyContext возвращает копию родительского контекста, которая помечается как выполненная (ее канал Done закрыт) при поступлении одного из перечисленных сигналов, при вызове возвращаемой функции stop или при закрытии канала Done родительского контекста, в зависимости от того, что произойдет раньше.
// замыкание — это функция, которая ссылается на переменные вне своего тела
// GOEXPERIMENT=loopvar избавит от хака для циклов `i := i`
// `var s = struct{}{}` Почему не следует использовать пустой интерфейс (var i interface{})? Потому что пустой интерфейс имеет ненулевой объем. Он занимает 8 байт в 32-битной архитектуре и 16 байт в 64-битной архитектуре. А пустая структура занимает 0 байт.
// запись/чтение отдельных ячеек в слайсе/массиве (но не в мапе) - потокобезопасно (не вызывает гонку данных)
// эти типы sync не должны копироваться: .Cond, .Map, .Mutex, .RWMutex, .Once, .Pool, .WaitGroup
// Когда вызов time.After повторяется (например, в цикле, в функции-потребителе Kafka или в обработчике HTTP), это может привести к пику в потреблении памяти. В таком случае используйте time.NewTimer.
// термины: кодирование (маршалинг) и декодирование (демаршалинг) данных JSON
// Операционная система поддерживает два разных типа часов: настенные (wall clock) и монотонные (monotonic clock). `time.Now()` содержит оба типа часов, а маршалинг данных JSON - только "wall clock". `time.Now().Truncate(0)` - способ сбросить "monotonic clock"
// t := time.Now().In(location) - время для определённого местоположения
// демаршалинг чисел any преобразуется в тип float64
// sql.Open может просто проверять правильность и действительность своих аргументов, не создавая соединение с базой данных (первое соединение может быть открыто лениво). Чтобы убедиться в доступности БД, применяйте метод Ping/PingContext.
// Stmt is a prepared statement (подготовленный оператор): `stmt, err := db.Prepare("SELECT * FROM ORDER WHERE ID = ?"); rows, err := stmt.Query(id); stmt.Close()`; если требуется предоставление какого-то дополнительного контекста: PrepareContext и QueryContext.
// `(sql.Rows).Next` подготавливает следующую строку результата для чтения методом `(sql.Rows).Scan`. Возвращается true в случае успеха или false, если следующая строка результатов отсутствует или при ее подготовке произошла ошибка. Чтобы отличить эти два случая, следует обратиться к `(sql.Rows).Err`.
// Все структуры, реализующие интерфейс io.Closer, в какой-то момент должны быть закрыты: `(sql.Rows).Close`, `(sql.Stmt).Close`, `(sql.DB).Close`, `(os.File).Close`, `(http.Response.Body).Close`
// `*http.Response.Body`, который возвращает `(http.Client).Get`, нужно закрывать после чтения методом `Close` (чтобы не оставлять утечку ресурсов); а если `(http.Client).Post` - тело ответа должно быть закрыто независимо от того, читаем ли мы его.
// Преимущество использования тегов сборки заключается в том, что можно выбирать, какие виды тестов выполнять. Запуск тестов с каким-то тегом включает в себя исполнение как файлов без тегов, так и файлов, соответствующих тегу. Например: `//go:build integration` + `go test --tags=integration -v .`
// Теги сборки имеют один главный недостаток: отсутствие сигналов о том, что тест проигнорирован. Переменная среды + (testing.T).Skip - способ сообщить о пропуске теста. Например: `if os.Getenv("INTEGRATION") != "true" { t.Skip("skipping integration test") }`
// `(testing).Short` + `go test -short -v .` - короткий режим для пропуска длительных тестов.
// если какой-то конкретный файл содержит тесты, которые приводят к гонке данных, мы можем исключить его из обнаружения гонок с помощью тега сборки `//go:build !race`
// (testing.T).Parallel() - метка о том, что тест должен выполняться параллельно
// `go test -parallel 16 .` - можно изменить GOMAXPROCS для запуска тестов параллельно
// `go test -shuffle=on -v .` - флаг для рандомизации тестов, то есть их выполнения в случайном порядке. возможные значения: on, off, seed (для повторного воспроизведения)
// (testing.T).FailNow() - FailNow помечает функцию как не выполнившуюся и останавливает ее выполнение вызовом runtime.Goexit (при этом выполняются все отложенные вызовы в текущей горутине).
// runtime.Goexit() - Goexit завершает вызывающую его горутину. Никакие другие горутины не затрагиваются. Goexit выполняет все отложенные вызовы перед завершением работы горутины. Поскольку Goexit не является паникой, все вызовы восстановления в этих отложенных функциях вернут nil. Вызов Goexit из главной горутины завершает эту горутину без возврата func main. Поскольку функция func main не вернулась, программа продолжает выполнение других программ. Если все остальные горутины завершаются, то программа терпит крах.
// (testing.B) .ResetTimer() .StopTimer() .StartTimer() - сбрасывает таймер бенчмарка
// bench perflock может ограничивать ресурсы CPU, которые может потреблять бенчмарк (только под Linux)
// `func TestMain(m *testing.M) { os.Exit(m.Run()) }` - Чтобы выполнять настройку и демонтаж каждого пакета, используйте функцию TestMain (применимо для интеграционных тестов).
// Wes Dyer: "Сделайте его правильным, сделайте его чистым, сделайте его кратким, сде- лайте его быстрым — именно в таком порядке".
// Принцип локальной ссылки (locality of reference): пространственная локализация кэша (будет сделано какое-то обращение к близлежащим ячейкам памяти), временная локализация кэша (к этому же месту памяти будет снова сделано какое-то обращение).
// Кэш-линия — это непрерывный сегмент памяти фиксированного размера, обычно 64 байта (8 переменных int64).
// как процессоры работают с данными: Unit stride, Constant stride, Non-unit stride, Critical stride (следует избегать, но пример из книжки не воспроизводится, видимо Go продвинулся в решении вопросов кеширования).
// Внутри CPU используется протокол MESI, гарантирующий когерентность кэша. Он отслеживает каждую кэш-линию, помечая ее как измененную, эксклюзивную, совместно используемую или недействительную (Modified, Exclusive, Shared и Invalid).
// Как уменьшить объем резервируемой памяти под выравнивания? Эмпирическое правило: реорга- низовать структуру так, чтобы ее поля сортировались по размеру типов в порядке убывания.
// Совместно используемые переменные, определенные в функции, которая вызывается из основного фрагмента кода (sharing up), отправляются в кучу. Как правило, совместно используемые переменные, определенные во фрагменте основного кода (sharing down), остаются в стеке. Если компилятор не может доказать (в результате escape-анализа), что переменная не используется после возврата из функции, то место для переменной выделяется в куче. Например: у каждой горутины свой стек, а куча общая для всех; глобальная переменная отправляется в кучу, т.к. к ней могут обращаться несколько горутин.
// `$ go build -gcflags "-m=2"` - флаг для обнаружения "escapes to heap"
// `//go:noinline` - запрет компилятору на inline-оптимизацию
// Какие примитивы синхронизации знаете? sync.Mutex, sync.RWMutex, sync.WaitGroup, sync.Cond, sync.Once, sync.Pool, sync/atomic
```
