# yandex

## Почему Go?

Это матерный язык в мире языков программирования, где простыми выразительными средствами можно сказать больше, чем на родном языке. Плюс gofmt снимает ограничения с выбором редактора.

- [Дзен Go](https://habr.com/ru/companies/vk/articles/490340/)
- [Изучите X за Y минут Где X=Go](https://learnxinyminutes.com/docs/ru-ru/go-ru/)
- [A Tour of Go](https://go.dev/tour/list)
- [Golang | Все Основы за 4 Часа Для Начинающих](https://www.youtube.com/watch?v=h0zxh2TPN_I)
- [Курс Go: онлайн обучение с нуля](https://code-basics.com/ru/languages/go)
- [Курс по изучению Golang для начинающих](https://golangify.com/go/kurs-izucheniya-golang-dlya-nachinayuschih)
- [golang-book.ru](http://golang-book.ru/)

## Code Style

- [What's in a name?](https://go.dev/talks/2014/names.slide)
- [uber-go-guide-ru](https://github.com/sau00/uber-go-guide-ru/blob/master/style.md)
- [Standard Go Project Layout](https://github.com/golang-standards/project-layout)
- [50 оттенков Go](https://habr.com/ru/companies/vk/articles/314804/)
- [Паттерны проектирования (с картинками)](https://refactoring.guru/ru/design-patterns/go)
- [Паттерны проектирования (с тестами)](https://github.com/AlexanderGrom/go-patterns)
- [Go Clean Architecture](https://github.com/comerc/go-clean-architecture)

## Practice

- [go-in-practice](https://github.com/diptomondal007/GoLangBooks/blob/master/go-in-practice.pdf)
- [building-microservices-go](https://github.com/diptomondal007/GoLangBooks/blob/master/building-microservices-go.pdf)
- [go-design-patterns-real-world-projects](https://github.com/diptomondal007/GoLangBooks/blob/master/Go_Design_Patterns_for_Real_World_Projects/go-design-patterns-real-world-projects.pdf)

## Опросник из "[Коллеги, вы меня огорчаете](https://habr.com/ru/companies/oleg-bunin/articles/521582/)"

### 1. Go — императивный или декларативный? А в чём разница?

Go является императивным языком программирования. В императивном программировании разработчик явно указывает, как выполнять определенные действия и контролирует изменение состояний программы.

Разница между императивным и декларативным программированием заключается в способе описания логики программы.

В императивном программировании разработчик указывает конкретные инструкции, как выполнить определенные действия. Программа последовательно выполняет эти инструкции и изменяет состояние программы. Примеры императивных языков программирования включают C, Java и Python.

В декларативном программировании разработчик описывает желаемый результат или состояние программы, а не конкретные шаги, которые нужно выполнить для достижения этого результата. Программа сама определяет, как достичь этого результата. Примеры декларативных языков программирования включают SQL, HTML и CSS.

Go является преимущественно императивным языком, поскольку разработчик явно указывает, как выполнять действия и контролировать изменение состояний программы. Однако, Go также предоставляет некоторые возможности для декларативного программирования, например, с использованием интерфейсов и структур данных.

### 2. Что такое type switch?

Type switch в Go - это конструкция языка, которая позволяет проверять тип значения и выполнять различные действия в зависимости от этого типа. Она представляет собой расширение обычного оператора switch, который используется для сопоставления значений с определенными случаями.

Вместо сопоставления значений с конкретными значениями, как в обычном операторе switch, type switch в Go позволяет сопоставлять значения с типами. Это особенно полезно, когда нужно выполнить разные действия в зависимости от типа значения.

Пример использования type switch в Go:

```go
var x interface{} = 42

switch x.(type) {
case int:
    fmt.Println("Это целое число")
case string:
    fmt.Println("Это строка")
default:
    fmt.Println("Неизвестный тип")
}
```

В этом примере переменная x имеет тип interface{}, и мы используем type switch для определения типа значения x и выполнения соответствующих действий. В зависимости от типа значения x, будет выведено соответствующее сообщение.

Type switch в Go позволяет более гибко обрабатывать различные типы значений, особенно в случаях, когда тип значения неизвестен заранее или может меняться.

### 3. Как сообщить компилятору, что наш тип реализует интерфейс?

В Go применяется "утиная типизация". Чтобы сообщить компилятору, что ваш тип реализует определенный интерфейс в Go, вам необходимо явно объявить это, указав имя интерфейса после имени типа в объявлении. Например:

```go
type MyType struct {
    // поля вашего типа
}

// MyType реализует интерфейс MyInterface
func (m MyType) SomeMethod() {
    // реализация метода интерфейса
}

type MyInterface interface {
    SomeMethod()
}
```

В этом примере тип MyType реализует интерфейс MyInterface. Мы объявляем метод SomeMethod() в MyType, который соответствует сигнатуре метода в интерфейсе MyInterface. Таким образом, компилятору будет известно, что тип MyType реализует интерфейс MyInterface.

Вы также можете явно указать, что тип реализует интерфейс, путем использования пустого идентификатора (\_), если вам не нужно использовать методы интерфейса внутри типа. Например:

```go
type MyType struct {
    // поля вашего типа
}

// MyType реализует интерфейс MyInterface
var _ MyInterface = MyType{}
```

В этом случае мы используем пустой идентификатор (\_), чтобы указать, что тип MyType реализует интерфейс MyInterface, но не используем методы интерфейса внутри типа.

### 4. Как работает append?

Функция append в Go используется для добавления элемента или элементов в конец среза (slice). Она имеет следующий синтаксис:

```go
newSlice := append(slice, element1, element2, ...)
```

Где slice - исходный срез, к которому вы хотите добавить элементы, element1, element2, и т.д. - элементы, которые вы хотите добавить в конец среза, и newSlice - новый срез, содержащий все элементы из исходного среза и добавленные элементы.

Функция append возвращает новый срез, поскольку в Go срезы являются ссылочными типами, и функция append может изменять принадлежащую память.

Если вам нужно добавить элементы из одного среза в другой, вы можете использовать оператор `...` для распаковки элементов из среза. Например:

```go
slice1 := []int{1, 2, 3}
slice2 := []int{4, 5, 6}

newSlice := append(slice1, slice2...)
```

В этом примере мы добавляем элементы из slice2 в конец slice1 с использованием оператора `...`.

Важно отметить, что функция append может изменить принадлежащую память, если вместимость (capacity) исходного среза недостаточна для добавления новых элементов. В таком случае будет создан новый срез с большей вместимостью, и исходный срез будет указывать на этот новый срез.

### 5. Какое у slice zero value? Какие операции над ним возможны?

Zero value для среза (slice) в Go является nil. Если вы объявляете срез без инициализации, его значение по умолчанию будет nil. Например:

```go
var s []int // zero value для среза - nil
```

Срезы с нулевым значением nil не содержат элементов и не указывают на какую-либо память. Они не являются действительными срезами и не могут быть использованы для выполнения операций, таких как чтение или запись элементов.

Операции, которые можно выполнить над срезом с нулевым значением nil, сводятся к проверке на нулевое значение или инициализации среза с помощью функции make. Например:

```go
var s []int

if s == nil {
    fmt.Println("Срез равен nil")
}

s = make([]int, 0)
```

В этом примере мы проверяем, является ли срез s нулевым значением nil. Затем мы инициализируем срез s с помощью функции make, чтобы он стал действительным срезом с нулевой длиной и вместимостью.

После инициализации среза с помощью make можно выполнять операции чтения, записи, добавления элементов и другие операции, которые поддерживаются срезами в Go.

### 6. Как устроен тип map?

Тип map в Go представляет собой ассоциативный массив или словарь, который состоит из набора пар ключ-значение. Ключи и значения могут быть любого типа, но все ключи должны быть одного типа, и все значения должны быть одного типа.

Внутри себя, map реализован как хэш-таблица, что обеспечивает эффективный доступ к значениям по ключу. Хэш-таблица является структурой данных, которая использует хэш-функцию для преобразования ключа в индекс внутреннего массива. Это позволяет быстро находить и обновлять значения по ключу.

Важно отметить, что порядок элементов в map не гарантирован и может меняться при каждой итерации по map. Если вам нужно гарантировать определенный порядок элементов, вы должны явно сортировать ключи или значения при необходимости.

Пример создания и использования map в Go:

```go
m := make(map[string]int)

m["apple"] = 1
m["banana"] = 2
m["cherry"] = 3

fmt.Println(m["banana"]) // Выводит: 2

delete(m, "cherry")

fmt.Println(len(m)) // Выводит: 2
```

В этом примере мы создаем map с типом string в качестве ключа и int в качестве значения. Мы добавляем несколько элементов в map, обращаемся к значению по ключу, удаляем элемент по ключу и выводим длину map.

### 7. Каков порядок перебора map?

Порядок перебора элементов в map в Go является неопределенным и не гарантированным. Это связано с тем, что map внутренне реализован как хэш-таблица, и порядок элементов может меняться при каждой итерации по map.

Если вам требуется определенный порядок элементов, вам необходимо явно сортировать ключи или значения перед их использованием. Например, вы можете сначала извлечь ключи из map в срез (slice), отсортировать этот срез и затем итерироваться по отсортированным ключам для доступа к значениям.

Пример сортировки ключей map перед итерацией:

```go
m := map[string]int{
    "banana": 2,
    "apple": 1,
    "cherry": 3,
}

keys := make([]string, 0, len(m))
for k := range m {
    keys = append(keys, k)
}

sort.Strings(keys)

for _, k := range keys {
    fmt.Println(k, m[k])
}
```

В этом примере мы создаем map с неупорядоченными ключами и значениями. Затем мы извлекаем ключи из map в срез keys, сортируем этот срез с помощью sort.Strings, а затем итерируемся по отсортированным ключам, чтобы получить доступ к соответствующим значениям.

Важно отметить, что сортировка выполняется на ключах, а не на значениях map. Если вам нужно сортировать по значениям, вы можете использовать дополнительные структуры данных или преобразовывать map в список пар ключ-значение и сортировать его.

### 8. Что будет, если читать из закрытого канала?

```go
ch := make(chan int, 5)
ch <- 1
ch <- 2
close(ch)

for {
    value, ok := <-ch
    if !ok {
        fmt.Println("Канал закрыт")
        break
    }
    fmt.Println(value)
}

// Ответ:
// 1
// 2
// Канал закрыт
```

В этом примере мы создаем буферизованный канал ch и добавляем в него два значения. Затем мы закрываем канал с помощью close(ch). В цикле мы пытаемся читать из канала и проверяем значение ok, чтобы определить, был ли канал закрыт или нет. Если канал закрыт, мы выходим из цикла.

Важно помнить, что после закрытия канала вы больше не можете в него писать, и попытка отправить значение в закрытый канал вызовет панику.

### 9. Что будет, если писать в закрытый канал?

Если вы пытаетесь записать значение в закрытый канал в Go, это вызовет панику (panic). Попытка отправить значение в закрытый канал считается ошибкой выполнения и приводит к аварийному завершению программы.

Это происходит потому, что после закрытия канала он больше не предназначен для записи. Закрытый канал остается доступным только для чтения. Попытка записи в закрытый канал указывает на ошибку в логике программы или неправильное использование канала.

Пример записи в закрытый канал:

```go
ch := make(chan int, 5)
close(ch)

ch <- 1 // Это вызовет панику
```

В этом примере мы создаем буферизованный канал ch и затем закрываем его с помощью close(ch). После закрытия канала мы пытаемся записать значение 1 в канал, что вызывает панику.

Важно правильно управлять состоянием каналов в программе и закрывать их только тогда, когда больше нет значений для отправки. Попытка записи в закрытый канал является ошибкой, которую нужно избегать.

### 10. Как вы отсортируете массив структур по алфавиту по полю Name?

Для сортировки массива структур по алфавиту по полю Name в Go, вы можете использовать интерфейс sort.Interface и функцию sort.Sort() из пакета sort.

Вот пример кода, который демонстрирует, как отсортировать массив структур по полю Name:

```go
package main

import (
    "fmt"
    "sort"
)

type Person struct {
    Name string
    Age  int
}

type ByName []Person

func (a ByName) Len() int           { return len(a) }
func (a ByName) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a ByName) Less(i, j int) bool { return a[i].Name < a[j].Name }

func main() {
    people := []Person{
        {Name: "Alice", Age: 25},
        {Name: "Charlie", Age: 30},
        {Name: "Bob", Age: 20},
    }

    sort.Sort(ByName(people))

    for _, person := range people {
        fmt.Println(person.Name, person.Age)
    }
}
```

В этом примере мы определяем тип Person для представления структуры человека с полями Name и Age. Затем мы определяем тип ByName, который является срезом структур Person. Мы также реализуем методы Len(), Swap(), и Less() для типа ByName, чтобы он соответствовал интерфейсу sort.Interface.

Затем мы создаем срез структур Person и заполняем его некоторыми значениями. Далее мы вызываем sort.Sort(ByName(people)), чтобы отсортировать срез структур по полю Name. Наконец, мы проходимся по отсортированному срезу и выводим отсортированные значения.

В результате выполнения этого кода вы увидите отсортированный по алфавиту список людей по полю Name, сопровождающийся их возрастом.

### 11. Что такое сериализация? Зачем она нужна?

Сериализация - это процесс преобразования объекта в формат, который может быть сохранен или передан через сеть, а затем восстановлен обратно в объект. Это может быть представление объекта в виде строки, байтового потока или другой структуры данных.

Сериализация полезна, когда вам нужно сохранить состояние объекта или передать его через сеть или между разными компонентами системы. Она позволяет сохранить данные объекта в постоянной или передаваемой форме и восстановить эти данные позже.

Некоторые основные причины использования сериализации включают:

- Передача данных через сеть: Сериализация позволяет упаковать данные объекта в байтовый поток или другой формат, который может быть передан через сеть, например, по протоколу HTTP или TCP/IP.

- Сохранение состояния объекта: Сериализация позволяет сохранить состояние объекта в файл или базу данных и восстановить его позже. Это полезно, например, для сохранения прогресса игры или хранения данных пользователя.

- Взаимодействие между разными языками программирования: Сериализация позволяет передавать данные между программами, написанными на разных языках программирования. Объекты сериализуются в общий формат, который может быть понятен и восстановлен на другом языке.

- Кэширование и копирование объектов: Сериализация может быть использована для создания копии объекта или для сохранения его состояния в кэше для повторного использования. Это может улучшить производительность и снизить нагрузку на систему.

Общий подход к сериализации включает выбор формата сериализации, определение, какие данные объекта должны быть сериализованы, и реализацию соответствующих методов (например, Serialize() и Deserialize()) для выполнения сериализации и десериализации объекта.

### 12. Сколько времени в минутах займет у вас написание процедуры обращения односвязного списка?

```go
package main

import "fmt"

type Node struct {
	Val  int
	Next *Node
}

func reverseLinkedList(head *Node) *Node {
	var prev *Node
	curr := head
	for curr != nil {
		Next := curr.Next
		curr.Next = prev
		prev = curr
		curr = Next
	}
	return prev
}

// можно сократить curr
// func reverseLinkedList(head *Node) *Node {
// 	var prev *Node
// 	for head != nil {
// 		Next := head.Next
// 		head.Next = prev
// 		prev = head
// 		head = Next
// 	}
// 	return prev
// }

// можно сократить Next (через множественное присваивание)
// func reverseLinkedList(head *Node) *Node {
// 	var prev *Node
// 	for head != nil {
// 		head.Next, prev, head = prev, head, head.Next
// 	}
// 	return prev
// }

// или создавая новые узлы
// func reverseLinkedList(head *Node) *Node {
//   var result *Node
//   curr := head
//   for curr != nil {
//     result = &Node{curr.Val, result}
//     curr = curr.Next
//   }
//   return result
// }

func printLinkedList(head *Node) {
	current := head
	for current != nil {
		fmt.Printf("%d -> ", current.Val)
		current = current.Next
	}
	fmt.Println("nil")
}

func main() {
	node1 := &Node{Val: 1}
	node2 := &Node{Val: 2}
	node3 := &Node{Val: 3}
	node4 := &Node{Val: 4}
	node5 := &Node{Val: 5}
	node1.Next = node2
	node2.Next = node3
	node3.Next = node4
	node4.Next = node5
	fmt.Println("Исходный список:")
	printLinkedList(node1)
	reversedHead := reverseLinkedList(node1)
	fmt.Println("Обращенный список:")
	printLinkedList(reversedHead)
}
```

### 13. Где следует поместить описание интерфейса: в пакете с реализацией или в пакете, где этот интерфейс используется? Почему?

Описание интерфейса следует помещать в пакете, где этот интерфейс используется, а не в пакете с реализацией. Это согласуется с принципом разделения интерфейса и реализации (Interface Segregation Principle) из принципов SOLID.

Согласно этому принципу, клиенты не должны зависеть от интерфейсов, которые они не используют. Помещение описания интерфейса в пакете, где он используется, позволяет клиентам работать с интерфейсом, не имея прямой зависимости от конкретной реализации.

Если описание интерфейса было бы помещено в пакете с реализацией, клиентам, которым нужно использовать этот интерфейс, пришлось бы иметь зависимость от пакета с реализацией. Это нарушает принцип разделения интерфейса и реализации и делает код менее гибким и сложным для поддержки и расширения.

Однако, хорошей практикой является помещение интерфейса и его реализации в одном пакете, если они плотно связаны и используются только внутри этого пакета. Это позволяет легче поддерживать код и обеспечивает более прозрачное использование интерфейса внутри пакета.

### 14. Предположим, ваша функция должна возвращать детализированные Recoverable и Fatal ошибки. Как это реализовано в пакете net? Как это надо делать в современном Go?

В пакете net в стандартной библиотеке Go возвращение детализированных ошибок реализовано с помощью ошибок, которые являются значениями пользовательских типов, реализующих интерфейс net.Error. Этот интерфейс определен следующим образом:

```go
type Error interface {
    error
    Timeout() bool   // возвращает true, если ошибка связана с таймаутом
    Temporary() bool // возвращает true, если ошибка является временной
}
```

Интерфейс net.Error включает методы Timeout() и Temporary(), которые позволяют клиентам проверять, является ли ошибка связанной с таймаутом или временной. Это позволяет клиентам принимать соответствующие действия в зависимости от типа ошибки.

В современном Go, начиная с версии 1.13, рекомендуется использовать синтаксис ошибок, основанный на типах, с помощью применения пакета errors и интерфейса fmt.Formatter. Этот подход позволяет создавать богатые по содержанию и информативные ошибки, которые могут хранить дополнительные данные и форматироваться в нужном формате при выводе.

Вот пример, как можно реализовать детализированные ошибки в современном Go:

```go
package main

import (
    "errors"
    "fmt"
)

type RecoverableError struct {
    Message string
}

func (e *RecoverableError) Error() string {
    return fmt.Sprintf("RecoverableError: %s", e.Message)
}

type FatalError struct {
    Message string
}

func (e *FatalError) Error() string {
    return fmt.Sprintf("FatalError: %s", e.Message)
}

func main() {
    err := doSomething()

    switch {
    case errors.Is(err, &RecoverableError{}):
        fmt.Println("Recoverable error:", err)
    case errors.Is(err, &FatalError{}):
        fmt.Println("Fatal error:", err)
    default:
        fmt.Println("Unknown error:", err)
    }
}

func doSomething() error {
    // Ваша логика здесь

    return &RecoverableError{Message: "Something went wrong"}
}
```

В этом примере у нас есть два типа ошибок: RecoverableError и FatalError. Оба типа реализуют интерфейс error и предоставляют дополнительные данные в своих методах Error(). Функция doSomething() возвращает ошибку типа RecoverableError.

Функция main() использует функцию errors.Is() для проверки типа ошибки и выполняет соответствующие действия в зависимости от типа ошибки.

Важно отметить, что настройка и использование детализированных ошибок может различаться в зависимости от конкретной задачи и предпочтений разработчика. Рекомендуется следовать общим рекомендациям и принципам языка Go при работе с обработкой ошибок. Например, рекомендуется использовать типы ошибок, которые являются значениями пользовательских типов и реализуют интерфейс error, чтобы их можно было легко сравнивать с помощью функции errors.Is(), как показано в примере выше. Также рекомендуется предоставлять информативные сообщения об ошибках, чтобы облегчить отладку и понимание причины ошибки.

Всегда стоит помнить, что обработка ошибок - важная часть разработки программного обеспечения, и хорошая практика заключается в предоставлении четкой информации о возникших ошибках, чтобы помочь пользователям программы или другим разработчикам понять, что пошло не так и как это исправить.

### 15. Главный недостаток стандартного логгера?

Один из главных недостатков стандартного логгера в языке программирования Go заключается в его ограниченных возможностях настройки и расширения. В стандартной библиотеке Go предоставляется пакет log, который включает в себя простой логгер с базовыми функциональными возможностями.

Несмотря на то, что стандартный логгер является простым и удобным в использовании инструментом для вывода сообщений в консоль или в файл, он имеет следующие недостатки:

- Ограниченная гибкость настройки: Стандартный логгер предоставляет ограниченные возможности для настройки формата вывода, уровня логирования и целевого места вывода. Например, он не поддерживает выбор формата вывода, смену цветов или выбор целевого файла журнала.

- Отсутствие поддержки логирования в несколько мест назначения: Стандартный логгер не предоставляет встроенной поддержки для направления логов в несколько мест назначения. Например, если вы хотите отправить логи одновременно в консоль и в файл, вам придется самостоятельно реализовать эту функциональность.

- Отсутствие поддержки ротации файлов журнала: Стандартный логгер не предоставляет встроенной поддержки для автоматической ротации файлов журнала. Если вы хотите сохранять логи в разных файлах или перезаписывать файл журнала после достижения определенного размера, вам придется самостоятельно реализовать эту функциональность.

- Отсутствие поддержки уровней логирования: Стандартный логгер не предоставляет встроенной поддержки для уровней логирования, таких как отладка (debug), информация (info), предупреждение (warning) и т. д. Вам придется самостоятельно управлять уровнем логирования и фильтровать сообщения в соответствии с вашими потребностями.

В целом, стандартный логгер в Go является простым и удобным инструментом для базового логирования, но при необходимости расширенных функций и настроек, возможно, потребуется использовать сторонние библиотеки или реализовать собственный логгер для удовлетворения конкретных требований вашего проекта.

### 16. Есть ли для Go хороший orm? Ответ обоснуйте.

Да, для Go существует несколько хороших ORM (Object-Relational Mapping) библиотек, которые облегчают работу с базами данных и предоставляют удобный способ выполнения операций CRUD (Create, Read, Update, Delete) через объектно-ориентированный интерфейс. Некоторые из популярных ORM библиотек для Go включают:

- GORM - это одна из самых популярных ORM библиотек для Go. Он предоставляет простой и удобный API для работы с базами данных, поддерживает различные драйверы баз данных, включая PostgreSQL, MySQL, SQLite и другие. GORM обладает широким функционалом, таким как автоматическое создание таблиц, миграции данных, поддержка отношений между таблицами и многое другое. Кроме того, GORM активно поддерживается сообществом разработчиков.

- XORM - это еще одна популярная ORM библиотека для Go, которая предоставляет удобные функции для работы с базами данных. XORM поддерживает различные базы данных, включая MySQL, PostgreSQL, SQLite и другие. Библиотека предлагает гибкую систему отображения моделей на таблицы базы данных, поддержку транзакций, миграции данных и другие полезные функции.

- Gorp - это относительно простая ORM библиотека для Go. Она предоставляет базовый набор функций для работы с базами данных, включая CRUD операции, отображение таблиц базы данных на структуры Go, поддержку транзакций и другие функции. Gorp поддерживает несколько баз данных, включая MySQL, PostgreSQL и SQLite.

Каждая из этих ORM библиотек имеет свои преимущества и недостатки, и выбор ORM зависит от конкретных требований и предпочтений разработчика. Однако, все они предоставляют удобные средства для работы с базами данных в Go и помогают упростить разработку приложений.

### 17. Какой у вас любимый линтер?

В сообществе Go разработчиков существует несколько популярных и широко используемых линтеров. Вот несколько из них:

- GolangCI-Lint является мощным линтером для Go, предлагающим множество проверок кода на основе нескольких популярных линтеров, таких как Go Vet, GoLint, и других. Он предоставляет множество полезных проверок, которые помогают выявить потенциальные проблемы в коде и следовать принятым стандартам разработки Go.

- Staticcheck - это другой популярный линтер для Go, который основан на статическом анализе кода. Он предлагает множество проверок, которые помогают выявить потенциальные ошибки, несоответствия стандартам кодирования и другие проблемы. Staticcheck известен своей скоростью и точностью.

- Revive - это линтер для Go, который предлагает набор проверок и правил для анализа и улучшения качества кода. Он поддерживает настраиваемые правила и предоставляет детализированные отчеты об ошибках и предупреждениях. Revive также интегрируется с различными инструментами разработки и средами разработки, такими как VS Code и Goland.

Важно отметить, что выбор линтера зависит от предпочтений разработчика и требований проекта. Каждый линтер имеет свои особенности и набор проверок, поэтому рекомендуется ознакомиться с документацией и экспериментировать с различными линтерами, чтобы выбрать тот, который лучше всего соответствует вашим потребностям и предпочтениям.

### 18. Можно ли использовать один и тот же буфер []byte в нескольких горутинах?

В Go можно использовать один и тот же буфер []byte в нескольких горутинах, но это требует дополнительных мер предосторожности для обеспечения безопасности и избежания гонок данных (data races).

Одним из подходов к безопасному использованию одного буфера []byte в нескольких горутинах является синхронизация доступа к нему с помощью мьютексов или других механизмов синхронизации, таких как sync.RWMutex. Мьютексы позволяют горутинам синхронизировать свой доступ к общему ресурсу и предотвращать одновременную запись или чтение из буфера.

Вот пример использования мьютекса для безопасного доступа к общему буферу []byte:

```go
var bufferMutex sync.Mutex
var buffer []byte

func writeToBuffer(data []byte) {
    bufferMutex.Lock()
    defer bufferMutex.Unlock()
    // Здесь происходит запись в буфер
    // ...
}

func readFromBuffer() []byte {
    bufferMutex.Lock()
    defer bufferMutex.Unlock()
    // Здесь происходит чтение из буфера
    // ...
    return buffer
}
```

В этом примере мьютекс bufferMutex используется для блокировки доступа к буферу []byte перед его записью или чтением. Это гарантирует, что только одна горутина имеет доступ к буферу в определенный момент времени.

Однако, важно помнить, что использование общего буфера []byte может быть проблематичным, особенно если горутины модифицируют его содержимое. Если горутины выполняют параллельные записи в буфер, могут возникнуть состояния гонки и непредсказуемые результаты. В таких случаях рекомендуется использовать другие механизмы синхронизации, такие как каналы (channels) или пулы буферов, чтобы гарантировать безопасность и предсказуемость работы с данными в многопоточной среде.

В целом, использование одного и того же буфера []byte в нескольких горутинах возможно, но требует осторожности и правильной синхронизации доступа к нему для обеспечения безопасности данных.

### 19. Какие типы мьютексов предоставляет stdlib?

Стандартная библиотека Go (stdlib) предоставляет два типа мьютексов для синхронизации доступа к общим ресурсам:

sync.Mutex: Это самый простой тип мьютекса, который предоставляется стандартной библиотекой Go. Он обеспечивает эксклюзивную блокировку (exclusive lock), что означает, что только одна горутина может захватить мьютекс и получить доступ к общему ресурсу. Если другая горутина пытается захватить мьютекс, пока он уже заблокирован, она будет ожидать его освобождения.

Пример использования sync.Mutex:

```go
var mutex sync.Mutex
var sharedResource int

// Горутина 1
mutex.Lock()
sharedResource = 42
mutex.Unlock()

// Горутина 2
mutex.Lock()
fmt.Println(sharedResource)
mutex.Unlock()
```

sync.RWMutex: Этот тип мьютекса, называемый также мьютексом чтения/записи (read/write mutex), обеспечивает более гибкую блокировку. Он позволяет нескольким горутинам захватывать мьютекс только для чтения (shared lock), разрешая параллельный доступ к общему ресурсу для чтения. Однако, при записи (exclusive lock) мьютекс блокируется, и другие горутины должны ждать его освобождения.

Пример использования sync.RWMutex:

```go
var rwMutex sync.RWMutex
var sharedResource int

// Горутина 1 для записи
rwMutex.Lock()
sharedResource = 42
rwMutex.Unlock()

// Горутина 2 для чтения
rwMutex.RLock()
fmt.Println(sharedResource)
rwMutex.RUnlock()
```

Оба типа мьютексов, sync.Mutex и sync.RWMutex, являются потокобезопасными и предоставляют механизмы для синхронизации доступа к общим ресурсам в многопоточной среде. Выбор между ними зависит от требований вашего кода: если вам нужна только эксклюзивная блокировка, используйте sync.Mutex, а если вам требуется поддержка одновременного чтения и блокировки записи, используйте sync.RWMutex.

### 20. Что такое lock-free структуры данных, и есть ли в Go такие?

Lock-free структуры данных - это структуры данных, которые разработаны таким образом, чтобы обеспечить потокобезопасность без использования блокировок (locks) или других механизмов синхронизации, которые могут приводить к блокировке (blocking). Вместо этого, они используют атомарные операции и другие конструкции языка, чтобы гарантировать безопасность доступа к данным в многопоточной среде без необходимости блокировки всего ресурса.

Lock-free структуры данных обычно стремятся к минимизации конфликтов и гонок данных между потоками, обеспечивая оптимальную производительность и масштабируемость в многопоточных приложениях.

В Go нет встроенных lock-free структур данных в стандартной библиотеке (stdlib). Однако, благодаря мощным примитивам синхронизации и атомарным операциям, предоставляемым пакетом sync/atomic, можно создать свои собственные lock-free структуры данных в Go.

sync/atomic предоставляет набор функций для выполнения атомарных операций над переменными, таких как чтение и запись без блокировки. Эти функции могут быть использованы для создания lock-free структур данных, таких как атомарные счётчики, списки или хеши.

Создание собственных lock-free структур данных требует глубокого понимания атомарных операций и синхронизации в Go. Они могут быть сложными в реализации и подвержены проблемам, таким как ABA-проблема. Поэтому, при разработке lock-free структур данных, рекомендуется обратиться к установленным практикам и библиотекам, разработанным сообществом Go, чтобы избежать потенциальных проблем и ошибок.

В заключение, хотя Go не имеет предопределенных lock-free структур данных в стандартной библиотеке, можно создать собственные lock-free структуры данных, используя примитивы синхронизации и атомарные операции, предоставляемые пакетом sync/atomic.

---

sync.Map - это тип данных в пакете sync в Go, который представляет собой безопасную для параллельного доступа карту (map). Он обеспечивает безопасное чтение и запись данных в карту из нескольких горутин без необходимости явной синхронизации.

sync.Map является потокобезопасным и предоставляет методы для чтения и записи данных. Он использует внутренние механизмы для обеспечения безопасности, включая механизмы блокировки и сегментированную хэш-таблицу.

Однако, важно отметить, что sync.Map не является полностью lock-free. Внутри sync.Map используется блокировка для защиты от гонок данных, но блокировка не накладывается на всю карту целиком. Вместо этого, она использует сегментированную хэш-таблицу, где каждый сегмент имеет свою собственную блокировку. Это позволяет горутинам независимо выполнять операции чтения и записи в разные сегменты карты, минимизируя блокировку и повышая производительность.

Таким образом, хотя sync.Map обеспечивает безопасность параллельного доступа к картам, он все равно использует блокировки для обеспечения этой безопасности.

### 21. Способы поиска проблем производительности на проде?

Поиск проблем производительности на продукционной среде может быть сложным и требует систематического подхода. Вот несколько способов, которые могут помочь вам найти проблемы производительности на проде:

- Мониторинг ресурсов: Используйте инструменты мониторинга, такие как системные метрики, мониторинг нагрузки CPU, памяти, диска и сети. Это поможет вам определить, какие ресурсы используются в большей степени и могут быть узкими местами.

- Профилирование кода: Используйте профилирование кода для идентификации узких мест в вашем коде. В Go вы можете использовать инструменты профилирования, такие как pprof и go tool pprof, чтобы получить информацию о времени выполнения и использовании памяти в вашей программе.

- Логирование: Разместите подробные и информативные логи в вашем приложении. Логирование может помочь идентифицировать узкие места в вашем коде или обнаружить неожиданные события или проблемы использования ресурсов.

- Измерение времени выполнения: Измерьте время выполнения различных частей вашего кода, чтобы определить, какие операции занимают больше всего времени. В Go вы можете использовать пакет time для измерения времени выполнения конкретных операций.

- Анализ запросов и данных: Используйте инструменты для анализа запросов и данных, чтобы найти более долгие или медленные запросы, определить проблемы с производительностью базы данных или идентифицировать неэффективные запросы.

- Масштабирование и горизонтальное масштабирование: Если ваше приложение испытывает проблемы с производительностью на проде, рассмотрите возможность масштабирования, как вертикального (увеличение ресурсов на одном сервере) и горизонтального (добавление дополнительных серверов). Это может помочь распределить нагрузку и повысить производительность.

- Анализ кода и оптимизация: Просмотрите свой код и ищите возможности для оптимизации. Иногда простые изменения в алгоритмах или структурах данных могут привести к значительному улучшению производительности.

Важно помнить, что поиск проблем производительности является итеративным процессом, и требует тщательного анализа и экспериментов. При обнаружении проблемы, попробуйте реализовать оптимизации и изменения, затем проведите тестирование и измерения производительности, чтобы убедиться, что внесенные изменения действительно улучшают производительность.

Также стоит помнить, что проблемы производительности могут быть вызваны различными факторами, включая неэффективный код, проблемы с инфраструктурой, сетью или базой данных. Поэтому важно анализировать не только код приложения, но и внутренние и внешние факторы, которые могут влиять на производительность.

Наконец, не забывайте о регулярном мониторинге и тестировании производительности вашего приложения на проде. Это поможет вам отслеживать изменения производительности с течением времени и реагировать на проблемы, которые могут возникнуть.

---

[Рефакторинг программы на Go: ускорение в 23 раза](https://habr.com/ru/companies/badoo/articles/415919/)

### 22. Стандартный набор метрик prometheus в Go-программе?

В Go-программе для сбора и экспорта метрик в Prometheus обычно используется пакет github.com/prometheus/client_golang/prometheus. Этот пакет предоставляет стандартный набор метрик и инструментов для работы с Prometheus.

Вот несколько основных типов метрик, которые можно использовать с помощью пакета prometheus:

Counter: Счетчики (Counter) представляют собой метрики, которые увеличиваются только вверх и никогда не уменьшаются. Они полезны для подсчета количества событий или запросов. Пример:

```go
counter := prometheus.NewCounter(prometheus.CounterOpts{
    Name: "my_counter",
    Help: "This is my counter",
})
counter.Inc()
```

Gauge: Градусники (Gauge) представляют собой метрики, которые могут изменяться вверх и вниз. Они полезны для отслеживания изменяющихся значений, таких как количество активных соединений или текущая нагрузка на систему. Пример:

```go
gauge := prometheus.NewGauge(prometheus.GaugeOpts{
    Name: "my_gauge",
    Help: "This is my gauge",
})
gauge.Set(42)
```

Histogram: Гистограммы (Histogram) представляют собой метрики, которые измеряют распределение значений в заданном диапазоне. Они полезны для измерения времени выполнения операций или размера запросов. Пример:

```go
histogram := prometheus.NewHistogram(prometheus.HistogramOpts{
    Name: "my_histogram",
    Help: "This is my histogram",
    Buckets: []float64{0.1, 0.5, 1, 2, 5},
})
histogram.Observe(0.6)
```

Summary: Суммары (Summary) также представляют собой метрики, которые измеряют распределение значений, но с учетом квантилей. Они полезны для измерения производительности и времени выполнения операций. Пример:

```go
summary := prometheus.NewSummary(prometheus.SummaryOpts{
    Name: "my_summary",
    Help: "This is my summary",
})
summary.Observe(2.5)
```

Кроме того, пакет github.com/prometheus/client_golang/prometheus также предоставляет дополнительные инструменты для регистрации метрик (Register), создания коллекторов (Collector), экспорта метрик (HTTPHandler) и т.д.

Это лишь небольшой обзор стандартного набора метрик, доступных в Go-программе через пакет prometheus. Более подробную информацию о создании и использовании метрик в Prometheus вы можете найти в официальной документации Prometheus для Go-программы: https://pkg.go.dev/github.com/prometheus/client_golang/prometheus

Там вы найдете более подробную информацию о различных типах метрик, настройке и регистрации метрик, использовании коллекторов, экспорте метрик через HTTP и многое другое.

### 23. Как встроить стандартный профайлер в свое приложение?

В Go вы можете использовать встроенный профайлер для сбора информации о производительности вашего приложения. Для этого вам нужно импортировать пакет net/http/pprof и зарегистрировать его обработчики HTTP.

Вот простой пример того, как встроить стандартный профайлер в свое приложение:

```go
package main

import (
    "log"
    "net/http"
    _ "net/http/pprof"
)

func main() {
    // Регистрируем обработчики профайлера
    go func() {
        log.Println(http.ListenAndServe("localhost:6060", nil))
    }()

    // Ваше приложение

    // ...
}
```

В этом примере мы импортируем пакет net/http/pprof и регистрируем его обработчики HTTP с помощью функции http.ListenAndServe(). Обработчики будут доступны по адресу localhost:6060.

После запуска вашего приложения вы можете открыть веб-браузер и перейти по адресу http://localhost:6060/debug/pprof/, чтобы получить доступ к различным профилировочным эндпоинтам. Например:

- http://localhost:6060/debug/pprof/profile - профилирование CPU
- http://localhost:6060/debug/pprof/heap - профилирование памяти
- http://localhost:6060/debug/pprof/block - профилирование блокировок
- http://localhost:6060/debug/pprof/goroutine - профилирование горутин

Вы можете использовать инструменты, такие как go tool pprof, чтобы анализировать собранные профилировочные данные и получать информацию о времени выполнения, утечках памяти, блокировках и других аспектах производительности вашего приложения.

Обратите внимание, что встроенный профайлер должен использоваться только для разработки и отладки, и не рекомендуется использовать его в продакшн-среде, так как он может иметь негативное влияние на производительность вашего приложения.

### 24. Overhead от стандартного профайлера?

Стандартный профайлер в Go имеет некоторый незначительный overhead, который может оказать влияние на производительность вашего приложения. Однако этот overhead обычно незначительный и не должен существенно замедлять ваше приложение.

Встроенный профайлер в Go использует счетчики аппаратного процессора для сбора информации о производительности. Это означает, что при использовании профайлера будет некоторое количество дополнительных инструкций процессора, которые потребуются для сбора этой информации.

Влияние профайлера на производительность может быть усилено, если ваше приложение уже работает с высокой интенсивностью процессора или имеет высокую нагрузку на память. В таких случаях, профайлирование может увеличить нагрузку на процессор и память, что может привести к замедлению выполнения вашего приложения.

Однако, стоит отметить, что overhead от профайлера обычно не является значительным и не должен быть проблемой в большинстве случаев. Если вы обнаружите, что профайлер существенно замедляет ваше приложение, то, возможно, имеет смысл использовать его только во время отладки и разработки, а не в продакшн-среде.

Если вы хотите более точно измерить overhead профайлера в вашем конкретном случае, вы можете использовать инструменты профилирования, такие как go tool pprof, чтобы анализировать профилировочные данные и определить, какое влияние профайлер оказывает на производительность вашего приложения.

В целом, стандартный профайлер в Go предоставляет ценную информацию о производительности вашего приложения, и его overhead обычно не является значительным. Однако, стоит оценить его использование в зависимости от конкретной ситуации и требований вашего приложения.

### 25. Почему встраивание — не наследование?

В программировании принцип "встраивания" (composition) и "наследования" (inheritance) являются двумя основными подходами к организации и повторному использованию кода.

Встраивание (composition) подразумевает создание нового объекта путем комбинации или включения других объектов. В этом случае, новый объект получает функциональность и поведение от включенных объектов, но не наследует их иерархию. Это позволяет более гибко комбинировать различные компоненты и организовывать код.

Наследование (inheritance), с другой стороны, подразумевает создание нового класса на основе существующего класса, называемого родительским классом или базовым классом. Новый класс, называемый дочерним классом или производным классом, наследует свойства и методы от родительского класса. Это позволяет дочернему классу наследовать и переопределять функциональность родительского класса.

Почему встраивание (composition) иногда предпочтительнее наследования (inheritance)? Вот несколько причин:

Гибкость: Встраивание позволяет комбинировать и переиспользовать компоненты более гибко, чем наследование. Вы можете создавать новые объекты, комбинируя функциональность нескольких других объектов, и изменять эту функциональность в любой момент.

Повторное использование: Встраивание позволяет повторно использовать компоненты в более широком контексте. Вы можете использовать один и тот же компонент в разных объектах или классах, что приводит к повышению эффективности и уменьшению дублирования кода.

Избегание проблем наследования: Наследование может приводить к проблемам, таким как неправильное использование наследуемой функциональности, сложность в поддержке и изменении иерархии классов, а также проблемы с переопределением методов. Встраивание позволяет избежать этих проблем, поскольку объекты не зависят от иерархии классов и не наследуют функциональность напрямую.

В целом, встраивание и наследование представляют разные подходы к организации и повторному использованию кода. Встраивание часто является предпочтительным подходом, так как он обеспечивает большую гибкость, повторное использование и избегает проблем, связанных с наследованием. Однако, выбор между встраиванием и наследованием зависит от специфических требований и контекста вашего проекта. В некоторых ситуациях наследование может быть более подходящим, особенно если важна иерархия классов и полиморфизм.

Важно помнить, что встраивание и наследование не являются взаимоисключающими. Они могут использоваться вместе, чтобы достичь определенных целей проектирования. Например, вы можете использовать встраивание для комбинирования нескольких компонентов и наследование для создания иерархии классов.

В конечном счете, выбор между встраиванием и наследованием зависит от конкретного проекта, его требований и целей. Оба подхода имеют свои преимущества и недостатки, и важно принимать решение на основе анализа контекста и потребностей вашего проекта.

### 26. Какие средства обобщенного программирования есть в Go?

На данный момент, Go не поддерживает полноценное обобщенное программирование (generic programming) в том смысле, в каком оно реализовано в некоторых других языках, таких как C++ или Java.

Однако, начиная с версии Go 1.18, в Go был представлен новый механизм, называемый "Type Parameters", который вводит возможность определения обобщенных функций и типов данных. Этот механизм позволяет создавать функции и типы, которые могут работать с различными типами данных без необходимости явного создания дублированного кода.

Механизм "Type Parameters" в Go позволяет определять параметры типа с помощью ключевого слова type и использовать их в определении функций и структур. Например, вот как может выглядеть определение обобщенной функции PrintSlice, которая печатает содержимое среза любого типа:

```go
func PrintSlice[T any](s []T) {
    for _, v := range s {
        fmt.Println(v)
    }
}
```

В этом примере, T является параметром типа, который может быть любым типом данных. Функция PrintSlice принимает срез типа T и печатает его содержимое.

Хотя новый механизм "Type Parameters" в Go предоставляет некоторую возможность обобщенного программирования, он все еще ограничен по сравнению с полноценными системами обобщений, такими как в C++ или Java. В частности, в Go не поддерживается создание обобщенных структур данных, таких как контейнеры (например, обобщенные списки или деревья).

В целом, обобщенное программирование в Go все еще находится на начальном этапе развития, и механизм "Type Parameters" в Go 1.18 предоставляет некоторые возможности для работы с обобщенным кодом. Однако, если вам требуется более мощный и полноценный механизм обобщений, вам может потребоваться использовать другие языки программирования, которые поддерживают обобщенное программирование изначально.

### 27. Какие технологические преимущества языка Go вы можете назвать?

Язык программирования Go (или просто Go) предлагает несколько технологических преимуществ, которые делают его популярным среди разработчиков. Ниже перечислены некоторые из этих преимуществ:

- Простота и эффективность: Go разработан с упором на простоту, читаемость и эффективность. Он имеет небольшое количество ключевых слов и простую синтаксическую структуру, что делает его легким для изучения и использования. Компилятор Go также генерирует быстрый и эффективный машинный код, что делает его подходящим для создания высокопроизводительных приложений.

- Конкурентность и параллелизм: Go включает в себя встроенную поддержку для работы с параллельными и конкурентными задачами. Он предоставляет механизмы горутин (goroutines) и каналов (channels), которые позволяют легко создавать и управлять множеством легковесных потоков выполнения. Это делает Go идеальным выбором для разработки сетевых и многопоточных приложений.

- Быстрая компиляция: Компилятор Go обладает высокой скоростью компиляции. Благодаря этому, разработчики могут быстро получать обратную связь от компилятора и быстро запускать свои программы. Быстрая компиляция также делает Go подходящим для разработки микросервисов и других приложений, где важна быстрая итерация разработки.

- Сборка мусора: Go имеет встроенную систему сборки мусора (garbage collection), которая автоматически управляет памятью и освобождает неиспользуемые объекты. Это позволяет разработчикам избежать ручного управления памятью и сосредоточиться на более высокоуровневых задачах.

- Кросс-платформенность: Go поддерживает кросс-платформенную разработку, что позволяет писать код один раз и запускать его на различных операционных системах, таких как Windows, macOS и Linux. Это упрощает разработку и обеспечивает переносимость приложений.

- Большая стандартная библиотека: Go имеет богатую стандартную библиотеку, которая предоставляет различные пакеты и модули для работы с сетью, вводом-выводом, шифрованием, кодированием, тестированием и многим другим. Это упрощает разработку приложений, так как множество функциональности уже встроено в стандартную библиотеку Go, что позволяет сэкономить время и усилия при разработке.

- Статическая типизация: Go является статически типизированным языком программирования, что означает, что типы переменных проверяются на этапе компиляции. Это помогает выявлять ошибки в коде на ранних стадиях разработки и повышает надежность и безопасность программ.

- Низкий уровень абстракции: Go предоставляет возможность писать код на низком уровне абстракции, что позволяет разработчикам более точно контролировать поведение программы. Это особенно полезно для разработки системного программного обеспечения, сетевых приложений и других приложений, где требуется более прямое взаимодействие с аппаратным и программным обеспечением.

Это лишь некоторые из преимуществ языка Go. Он также активно развивается сообществом разработчиков, имеет широкую поддержку и активную экосистему инструментов и библиотек, что делает его привлекательным выбором для различных типов проектов.

### 28. Какие технологические недостатки языка Go вы можете назвать?

Хотя язык программирования Go имеет множество преимуществ, есть и некоторые технологические недостатки, о которых следует упомянуть. Ниже приведены некоторые из них:

- Отсутствие полноценной поддержки обобщенного программирования: До версии Go 1.18, Go не поддерживал полноценное обобщенное программирование (generic programming). Это означает, что вам может потребоваться повторять код для работы с разными типами данных, что может привести к дублированию кода и увеличению размера программы. Однако, с введением механизма "Type Parameters" в Go 1.18, эта проблема стала менее значимой.

- Ограниченные возможности работы с исключениями: Go использует механизм ошибок (error) для обработки ошибок, вместо механизма исключений, который присутствует в некоторых других языках. Это может потребовать больше усилий со стороны разработчика при обработке ошибок и может привести к более громоздкому коду, особенно в сложных сценариях обработки ошибок.

- Отсутствие некоторых продвинутых языковых конструкций: Go был разработан с упором на простоту и минимализм, и некоторые продвинутые языковые конструкции, такие как функциональное программирование или оператор перегрузки, отсутствуют в языке. Это может ограничить некоторые возможности разработки и потребовать более традиционных подходов к решению задач.

- Менее развитая экосистема библиотек: В сравнении с некоторыми другими языками программирования, экосистема библиотек и инструментов Go может быть менее развитой. Хотя стандартная библиотека Go предлагает множество функциональности, некоторые специфические библиотеки или инструменты могут быть менее доступными или иметь меньшее количество альтернатив.

- Ограниченная поддержка для некоторых архитектур и платформ: В настоящее время Go имеет ограниченную поддержку для некоторых архитектур и платформ, особенно в сравнении с более установленными языками программирования. Это может ограничить возможности разработки для некоторых специфических платформ и требовать дополнительных усилий для портирования кода на такие платформы.

Несмотря на эти недостатки, Go все равно является мощным и популярным языком программирования, особенно в области разработки сетевых и многопоточных приложений. Он обладает простым и понятным синтаксисом, эффективной компиляцией, поддержкой параллелизма и широкой стандартной библиотекой, что делает его привлекательным выбором для множества проектов.

## ООП

В GoLang не реализованы некоторые особенности объектно-ориентированного программирования, такие как наследование классов и конструкторы. Однако, Go предлагает другие механизмы для достижения тех же целей, например, встраивание структур и интерфейсы.

Инкапсуляция достигается с помощью именованных и неименованных идентификаторов (публичные и приватные). Идентификаторы, начинающиеся с заглавной буквы, являются публичными и могут быть доступными из других пакетов. Идентификаторы, начинающиеся с маленькой буквы, являются приватными и доступны только в пределах своего пакета. Однако, в Go нет строгой приватности, и другие пакеты могут иметь доступ к приватным идентификаторам, если они находятся в том же пакете импорта.

Полиморфизм достигается через интерфейсы. Интерфейсы в Go позволяют создавать общие типы данных, которые могут быть реализованы разными конкретными типами. Это позволяет использовать эти типы данных в общем контексте и вызывать их методы без необходимости знать конкретную реализацию. Таким образом, в GoLang можно достичь полиморфизма, хотя это не основной акцент данного языка.

Есть поддержка абстракции через интерфейсы. Интерфейсы в Go позволяют определить набор методов, которые должны быть реализованы для типа данных. Это позволяет создавать абстрактные типы данных и работать с ними, не завися от конкретной реализации.

Объявление или привязка структуры к методу называется "методом-получателем" (method receiver). При объявлении метода для структуры, указывается получатель - тип структуры, к которому привязывается метод. Это позволяет вызывать методы на экземплярах этой структуры.

## Термины

- [0-15) полуинтервал на числовую прямую
- компоратор - функция, которая возвращает -1 || 0 || 1
- ресивер – это объявление типа, для которого вы хотите определить метод.

## Указатели

- `*` - разыменование указателя (пример: a := \*b), но для арументов функции - тип указателя
- `&` - взятие адреса (пример: a := &b - положить в переменную указатель на значение)

- в Gо нет ссылок, только указатели (ссылки есть в c/c++).
- у переменой есть значение, адрес ссылки это адрес значения, а указатель на значение имеет свой собственный адрес (​это очень грубое объяснение).

## interface{}

- алиас any
- x.(MyType) - это "утверждение типа" (а не "приведение типа", как например: float64 к int)
- x.(type) - это "извлечение типа"

## Кортежи (tuples)

В языке Go кортежи (tuples) не являются встроенной частью языка, в отличие от некоторых других языков программирования, таких как Python. Однако, вы можете достичь похожего поведения с помощью структур или слайсов.

С использованием структур, вы можете определить тип данных, который содержит несколько полей, которые могут быть разного типа. Например:

```go
type Tuple struct {
    Field1 int
    Field2 string
    Field3 float64
}

func main() {
    tuple := Tuple{Field1: 1, Field2: "Hello", Field3: 3.14}
    fmt.Println(tuple.Field1, tuple.Field2, tuple.Field3)
}
```

Вы также можете использовать слайсы (slices) для создания коллекции значений без явного определения структуры. Например:

```go
func main() {
    tuple := []interface{}{1, "Hello", 3.14}
    fmt.Println(tuple[0], tuple[1], tuple[2])
}
```

Однако, использование структур или слайсов вместо кортежей может быть менее удобным, так как вам может потребоваться обращаться к элементам по индексам или использовать дополнительные проверки типов.

## Ссылочные типы данных

Ссылочные типы данных в GoLang - это типы данных, которые хранятся в системной куче (heap) и передаются по ссылке, а не по значению. Это означает, что при передаче ссылочного типа данных в функцию, функция работает с оригинальным объектом, а не с его копией. Некоторые из ссылочных типов данных в GoLang:

- Срезы (slices) - это динамические массивы, которые представляют собой ссылку на последовательность элементов определенного типа.
- Карты (maps) - это ассоциативные массивы, которые представляют собой ссылку на набор пар ключ-значение.
- Каналы (channels) - это механизм для обмена данными между горутинами (goroutines) в многопоточной программе.
- Указатели (pointers) - это переменные, которые хранят адрес в памяти другой переменной.
- ?? Структуры (structs) - это пользовательские типы данных, которые могут содержать поля разных типов.
- Интерфейсы (interfaces) - это типы данных, которые определяют набор методов, которые должны быть реализованы для типа данных, чтобы он удовлетворял интерфейсу.
- Функции (functions) - это типы данных, которые могут быть переданы в качестве аргументов другим функциям или возвращены из функций.

Все эти типы данных являются ссылочными в GoLang и передаются по ссылке, а не по значению.

Нельзя сравнивать []int{1,2,3} == []int{1,2,3}, в отличии от [3]int{1,2,3} == [3]int{1,2,3}

Поправка:

В GoLang тип данных `struct` является составным типом данных, который объединяет несколько полей разных типов данных в один объект. `struct` не является ссылочным типом данных, а является значимым типом данных, то есть при передаче `struct` в функцию или присваивании его переменной происходит копирование значений его полей. Однако, при передаче `struct` в функцию в качестве аргумента, происходит передача его копии, что может быть неэффективно для больших `struct`. В таких случаях можно использовать указатели на `struct`.

## Передача слайса как аргумента функции

Длина и вместимость передаются по значению, но массив значений передается по ссылке. Вследствие этого получается неявное поведение: добавленные элементы не сохранятся в исходный слайс, но изменение существующих останется.

```go
package main

import "fmt"

func main() {
	cap := 4 // если 3, то ответы разные; если 4 - одинаковые
	var a = make([]int, 0, cap)
	a = append(a, 111, 222, 333)

	fmt.Printf("%#v\n", getArray(a))
	fmt.Printf("%#v\n", a)
}

func remove(slice []int, s int) []int {
	return append(slice[:s], slice[s+1:]...)
}

func getArray(a []int) []int {
	a = append(a, 444)
	a = remove(a, 0)
	return a
}
```

Общий формат среза: a[начало:конец:шаг]. Если начало не указано, то по умолчанию начало считается 0. Если конец не указан, то по умолчанию конец считается длиной массива. Если шаг не указан, то по умолчанию шаг считается равным 1.

Эмпирически установлено. Если отрезать слайс сначала, то capacity уменьшается до новой длины, а если с конца, то остаётся равен исходному размеру слайса. Третий параметр позволяет указать capacity явно (но не больше исходного), и он тоже уменьшается от указанного, если отрезать слайс сначала.

Если append() добавляет новый элемент в слайс, у которого превышена capacity, то capacity увеличивается в два раза от исходного. Но если добавлять за раз несколько элементов (больше чем в два раза от исходного), то дальше capacity увеличивается с шагом два.

Видео: [Что нужно знать о слайсах в Go](https://www.youtube.com/watch?v=1vAIvqDo5LE)

<details>
	<summary>Больше практики</summary>

```go
package main

import (
	"fmt"
)

// что будет выведено?
// если где-то будет паника, то в какой сторке и почему?

func example1Slice() {
	var slice []int
	fmt.Printf("slice is nil %t\n", slice == nil) // true (!)
	slice2 := []int{}
	fmt.Printf("slice2 is nil %t\n", slice2 == nil) // false
	// append() увеличивает емкость среза в два раза:
	slice = append(slice, 1)
	fmt.Printf("slise = %+v len = %d; cap = %d;\n", slice, len(slice), cap(slice))
	// slise = [1] len = 1 cap = 1
	slice = append(slice, 2)
	fmt.Printf("slice = %+v len = %d; cap = %d;\n", slice, len(slice), cap(slice))
	// slise = [1, 2] len = 2 cap = 2
	slice = append(slice, 3)
	fmt.Printf("slice = %+v len = %d; cap = %d;\n", slice, len(slice), cap(slice))
	// slise = [1, 2, 3] len = 3 cap = 4 (!)
}

func example2Slice() {
	sl := []int{1, 2, 3, 4, 5, 6}
	sl1 := sl[:3]
	sl2 := sl[1:3:4]

	fmt.Printf("sl1 = %+v len = %d; cap = %d;\n", sl1, len(sl1), cap(sl1))
	// sl1 = [1, 2, 3] len = 3 cap = 6
	fmt.Printf("sl2 = %+v len = %d; cap = %d;\n", sl2, len(sl2), cap(sl2))
	// sl2 = [2, 3] len = 2 cap = 3

	sl2 = append(sl2, 9)
	sl1 = sl1[:4]

	fmt.Printf("sl = %+v len = %d; cap = %d;\n", sl, len(sl), cap(sl))
	// sl = [1, 2, 3, 9, 5, 6] len = 6 cap = 6
	fmt.Printf("sl1 = %+v len = %d; cap = %d;\n", sl1, len(sl1), cap(sl1))
	// sl1 = [1, 2, 3, 9] len = 4 cap = 6
	fmt.Printf("sl2 = %+v len = %d; cap = %d;\n", sl2, len(sl2), cap(sl2))
	// sl2 = [2, 3, 9] len = 3 cap = 3

	add(sl1, 8)
	fmt.Printf("sl = %+v len = %d; cap = %d;\n", sl, len(sl), cap(sl))
	// sl = [1, 2, 3, 9, 8, 6] len = 6 cap = 6
	fmt.Printf("sl1 = %+v len = %d; cap = %d;\n", sl1, len(sl1), cap(sl1))
	// sl1 = [1, 2, 3, 9] len = 4 cap = 6
	fmt.Printf("sl2 = %+v len = %d; cap = %d;\n", sl2, len(sl2), cap(sl2))
	// sl2 = [2, 3, 9] len = 3 cap = 3

	changeSlice(sl, 5, 20)
	fmt.Printf("sl = %+v len = %d; cap = %d;\n", sl, len(sl), cap(sl))
	// sl = [1, 2, 3, 9, 8, 20] len = 6 cap = 6

	sl = append(sl, 7)
	fmt.Printf("sl = %+v len = %d; cap = %d;\n", sl, len(sl), cap(sl))
	// sl = [1, 2, 3, 9, 8, 20, 7] len = 7 cap = 12

	// sl1 = sl1[:7] - panic, cap = 6
	// fmt.Printf("sl1 = %+v len = %d; cap = %d;\n", sl1, len(sl1), cap(sl1))
	// sl1 = [1, 2, 3, 9] len = 4 cap = 6
}

func example3Map() {
	var myMap map[int]int
	fmt.Printf("myMap is nil %t len = %d;\n", myMap == nil, len(myMap)) // true, len = 0
	// myMap[5] = 55 // panic
	// fmt.Printf("myMap is nil %t len = %d;\n", myMap == nil, len(myMap))

	myMap = map[int]int{}
	fmt.Printf("myMap is nil %t len = %d;\n", myMap == nil, len(myMap)) // false, len = 0
	changeMap(myMap, 6, 66)
	fmt.Printf("myMap is nil %t len = %d;\n", myMap == nil, len(myMap)) // false, len = 1
}

func changeSlice(sl []int, idx int, val int) {
	if 0 <= idx && idx < len(sl) {
		sl[idx] = val
	}
}

func changeMap(myMap map[int]int, key int, val int) {
	myMap[key] = val
}

func add(sl []int, val int) {
	sl = append(sl, val)
}

func main() {
	// example1Slice()
	// example2Slice()
	example3Map()
}

```

</details>

## Heap

Куча (heap) - это структура данных, которая упорядочивает элементы в виде двоичного дерева, при этом каждый узел имеет значение, которое не меньше (для кучи минимумов) или не больше (для кучи максимумов) значений его потомков. В GoLang куча представлена типом `heap.Interface`, который описывает методы, необходимые для работы с кучей:

```go
// heap.go
type Interface interface {
	sort.Interface
	Push(x any) // add x as element Len()
	Pop() any   // remove and return element Len() - 1.
}
// sort.go
type Interface interface {
	// Len is the number of elements in the collection.
	Len() int

	// Less reports whether the element with index i
	// must sort before the element with index j.
	//
	// If both Less(i, j) and Less(j, i) are false,
	// then the elements at index i and j are considered equal.
	// Sort may place equal elements in any order in the final result,
	// while Stable preserves the original input order of equal elements.
	//
	// Less must describe a transitive ordering:
	//  - if both Less(i, j) and Less(j, k) are true, then Less(i, k) must be true as well.
	//  - if both Less(i, j) and Less(j, k) are false, then Less(i, k) must be false as well.
	//
	// Note that floating-point comparison (the < operator on float32 or float64 values)
	// is not a transitive ordering when not-a-number (NaN) values are involved.
	// See Float64Slice.Less for a correct implementation for floating-point values.
	Less(i, j int) bool

	// Swap swaps the elements with indexes i and j.
	Swap(i, j int)
}
```

![](./assets/heap.png)

На картинке показано справа, как выглядит куча минимумов (i.e. "Priority Queue"), где каждый узел имеет значение, которое не меньше значений его потомков. В куче минимумов наименьший элемент всегда находится в корне дерева, что делает его полезным для решения ряда задач, таких как нахождение k наименьших элементов в списке или поиск медианы в потоке данных. Для работы с кучей можно использовать пакет `container/heap`, который предоставляет реализацию кучи минимумов и максимумов, а также методы для работы с ней, такие как `Push()`, `Pop()`, `Fix()`, `Remove()`, и другие.

Добавление нового элемента в кучу выполняется путем помещения элемента в последнюю свободную позицию в массиве и затем "всплытия" его вверх по дереву, пока не будет найдена его правильная позиция. Удаление элемента с наименьшим (наибольшим) значением выполняется путем замены его последним элементом в массиве, после чего он "просеивается" вниз по дереву, пока не будет найдена его правильная позиция.

## DFS/BFS

DFS (Depth-First Search) и BFS (Breadth-First Search) - это два алгоритма поиска в графе. DFS ищет в глубину, переходя на каждый уровень графа, пока не будет найден целевой узел или не будут исследованы все узлы. BFS ищет в ширину, посещая все узлы на одном уровне перед переходом к узлам следующего уровня. Оба алгоритма могут быть использованы для поиска кратчайшего пути в невзвешенном графе, но только BFS может быть использован для этой цели во взвешенном графе.

Взвешенный граф - это граф, в котором каждому ребру присвоено некоторое числовое значение, называемое весом. Вес может отражать, например, расстояние между двумя вершинами, стоимость перехода от одной вершины к другой и т.д. Взвешенный граф используется для решения задач, связанных с оптимизацией и нахождением кратчайшего пути между вершинами. Для поиска кратчайшего пути в взвешенном графе обычно используется алгоритм Дейкстры или алгоритм Флойда-Уоршелла.

## Dynamic Programming

Динамическое программирование — способ решения сложных задач путём разбиения их на более простые подзадачи. Он применим к задачам с оптимальной подструктурой, которые выглядят как набор перекрывающихся подзадач, сложность которых чуть меньше исходной. В этом случае время вычислений, по сравнению с «наивными» методами, можно значительно сократить.

Ключевая идея в динамическом программировании достаточно проста. Как правило, чтобы решить поставленную задачу, требуется решить отдельные части задачи (подзадачи), после чего объединить решения подзадач в одно общее решение. Часто многие из этих подзадач одинаковы. Подход динамического программирования состоит в том, чтобы решить каждую подзадачу только один раз, сократив тем самым количество вычислений. Это особенно полезно в случаях, когда число повторяющихся подзадач экспоненциально велико.

Метод динамического программирования сверху — это простое запоминание результатов решения тех подзадач, которые могут повторно встретиться в дальнейшем. Динамическое программирование снизу включает в себя переформулирование сложной задачи в виде рекурсивной последовательности более простых подзадач.

Разница между динамическим программированием и жадными алгоритмами заключается в том, что при динамическом программировании существуют перекрывающиеся подпроблемы, и эти подпроблемы решаются с помощью мемоизации. "Мемоизация" - это техника, при которой решения подпроблем используются для более быстрого решения других подпроблем.

Разница в том, что динамическое программирование требует запоминания ответа для меньших состояний, в то время как жадный алгоритм является локальным в том смысле, что вся необходимая информация находится в текущем состоянии. Конечно, существует некоторое пересечение.

## Greedy Method

Жадный алгоритм — алгоритм, заключающийся в принятии локально оптимальных решений на каждом этапе, допуская, что конечное решение также окажется оптимальным. В общем случае нельзя сказать, можно ли получить оптимальное решение с помощью жадного алгоритма применительно к конкретной задаче. Но есть две особенности, характерные для задач, которые решаются с помощью жадных алгоритмов: принцип жадного выбора и свойство оптимальности для подзадач.

### Принцип жадного выбора

Говорят, что к задаче оптимизации применим принцип жадного выбора, если последовательность локально оптимальных выборов даёт глобально оптимальное решение. В этом состоит главное отличие жадных алгоритмов от динамического программирования: во втором просчитываются сразу последствия всех вариантов.

Чтобы доказать, что жадный алгоритм даёт оптимум, нужно попытаться провести доказательство, аналогичное доказательству алгоритма задачи о выборе заявок. Сначала мы показываем, что жадный выбор на первом шаге не закрывает путь к оптимальному решению: для любого решения есть другое, согласованное с жадным выбором и не хуже первого. Потом мы показываем, что подзадача, возникшая после жадного выбора на первом шаге, аналогична исходной. По индукции будет следовать, что такая последовательность жадных выборов даёт оптимальное решение.

### Оптимальность для подзадач

Это свойство говорит о том, что оптимальное решение всей задачи содержит в себе оптимальные решения подзадач.

## Хвостовая рекурсия

Хвостовая рекурсия - это особый тип рекурсии, при котором вызов рекурсивной функции происходит в самом конце тела функции, после ее вычислительной работы. Такой подход позволяет компилятору или интерпретатору оптимизировать код и не сохранять значения всех промежуточных вызовов в стеке вызовов, что может привести к проблемам с памятью. Вместо этого, компилятор или интерпретатор могут заменить несколько последовательных вызовов рекурсивной функции на один вызов, используя только один фрейм стека вызовов. Это снижает использование памяти и повышает производительность.

Хвостовая рекурсия не оптимизируется автоматически в Go, так как это не является частью спецификации языка. Однако, в Go можно реализовать функции с использованием хвостовой рекурсии вручную, используя циклы или генераторы. Например, функция для вычисления факториала с помощью хвостовой рекурсии в Go могла бы выглядеть следующим образом:

```go
func factorialHelper(n int, acc int) int {
	if n == 0 {
		return acc
	}
	return factorialHelper(n-1, n*acc)
}

func factorial(n int) int {
	return factorialHelper(n, 1)
}
```

Эта реализация использует вспомогательную функцию `factorialHelper`, которая берет два аргумента: `n` - число, факториал которого мы хотим вычислить, и `acc` - аккумулятор, который будет хранить результат вычисления. Функция `factorial` вызывает `factorialHelper` с начальным значением аккумулятора равным `1`. Каждый раз, когда `factorialHelper` вызывает саму себя, она передаёт в качестве параметров `n-1` и `n*acc`. Таким образом, рекурсия превращается в цикл, который завершается, когда `n` равно `0`. Это позволяет избежать переполнения стека и сделать функцию более производительной.

Хвостовая рекурсия не должна быть использована в тех случаях, когда результат вычисления функции зависит от результата всех вызовов функции в цепочке рекурсии, а не только от последнего вызова. Например, рассмотрим следующую рекурсивную функцию для вычисления чисел Фибоначчи:

```go
func fibonacci(n int) int {
	if n == 0 {
		return 0
	} else if n == 1 {
		return 1
	} else {
		return fibonacci(n-1) + fibonacci(n-2)
	}
}
```

Здесь для вычисления `n`-го числа Фибоначчи функция вызывает себя два раза - для вычисления `(n-1)`-го и `(n-2)`-го чисел. Каждый вызов функции возвращает результат, который необходим для вычисления итогового результата. В этом случае, хвостовая рекурсия не применяется, так как при оптимизации хвостовой рекурсии сохраняется только последний вызов функции, а результаты предыдущих вызовов теряются. Поэтому, для вычисления чисел Фибоначчи, требуется использовать обычную рекурсию.

## Про сложность алгоритма O(n)

Сложность алгоритма это величина, которая измеряет количество инструкций процессора затраченное на выполнение алгоритма.

Если есть цикл пробегающий по всем элементам массива из n элементов, то это значит что процессору потребуется выполнить n инструкций, следовательно сложность будет O(n).

При оценке сложности всегда считается худший случай, то есть, если мы выходим из цикла при нахождении ответа раньше, то сложность всё равно будет O(n), так как в худшем случае ответ будет в последнем ​элементе массива.

Из этого следует что сложность алгоритма с двумя вложенными циклами квадратична, то есть O(n^2) и т.д.

Если алгоритм выполняется за строго ограниченное количество инструкций (например обращение к элементу массива по индексу), то такая сложность называется константной O(1).

​Есть ещё факториальная сложность O(n!) такая сложность очень плоха, и алгоритмы вообще не эффективны. Также как и сложность O(2^n). Пример такого алгоритма - рекурсивное вычисление чисел Фиббаначи (вариант без мемоизации).

Замечание: O(n^2) не равно O(2^n). Временная сложность O(n^2) означает, что время выполнения алгоритма увеличивается квадратично с увеличением размера входных данных, тогда как O(2^n) означает экспоненциальную временную сложность, при которой время выполнения алгоритма увеличивается экспоненциально с увеличением размера входных данных.

Стоит оговориться, если нас просят оценить, например, сложность добавления элемента в массив, то тут будет сложность O(1\*), так называемая амортизированная сложность. То есть добавляем элемент всегда за O(1), но когда нам нужно запросить новую память для элемента при расширении создастся новый массив и туда всё скопируется. Сложность будет O(n).

![](./assets/algo.png)

Пояснения: O – оценка для худшего случая, Ω – оценка для лучшего случая, Θ – оценка для среднего случая.

## Про O(log n)

O(log n) - это алгоритмическая сложность, которая означает, что время выполнения алгоритма увеличивается не пропорционально размеру входных данных (n), а по логарифмической шкале. То есть, при увеличении n в 10 раз, время выполнения алгоритма увеличится только на несколько единиц.

Это очень эффективная сложность, и она часто встречается в алгоритмах, которые работают с отсортированными данными, такими как бинарный поиск. В бинарном поиске мы делим отсортированный массив пополам на каждом шаге, что дает нам O(log n) времени выполнения.

Однако, не все алгоритмы могут работать с O(log n) сложностью. Например, сортировка пузырьком имеет O(n^2) сложность, что означает, что время выполнения алгоритма увеличивается пропорционально квадрату размера входных данных. Поэтому важно выбирать подходящий алгоритм в зависимости от задачи, которую необходимо решить.

## Про O(n log n)

O(n \* log(n)) означает, что время выполнения алгоритма увеличивается в логарифмической пропорции с увеличением размера входных данных. Это временная сложность, которая является более быстрой, чем квадратичная O(n^2), но медленнее, чем линейная O(n) или константная O(1). Алгоритмы с временной сложностью O(n log n) часто используются в сортировке данных, например, быстрой сортировке (quicksort) или сортировке слиянием (merge sort).

## Книжки про Алгоритмы

Для изучения оценки сложности алгоритма по "time complexity" & "space complexity" можно начать с книги "Introduction to Algorithms" авторов Кормена, Лейзерсона, Ривеста и Штайна. Это общепризнанная книга по алгоритмам, которая покрывает базовые алгоритмические концепции, включая оценку временной и пространственной сложности. Книга также содержит множество примеров и задач для практического применения.

Или же книжка "[Грокаем алгоритмы](https://en.ecomed.dgmu.ru/wp-content/uploads/2020/01/%D0%93%D1%80%D0%BE%D0%BA%D0%B0%D0%B5%D0%BC_%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC%D1%8B.pdf)".

Или ещё [Основы алгоритмов - интерактив от Yandex](https://academy.yandex.ru/handbook/algorithms)

Из YouTube: [ВСЯ СЛОЖНОСТЬ АЛГОРИТМОВ ЗА 11 МИНУТ](https://www.youtube.com/watch?v=cXCuXNwzdfY)

## [/article](./article/) - алгоритмические задачи

- [Как проходят алгоритмические секции на собеседованиях в Яндекс](https://habr.com/ru/companies/yandex/articles/449890/)

### Задача A. Камни и украшения

> Даны две строки строчных латинских символов: строка J и строка S. Символы, входящие в строку J, — «драгоценности», входящие в строку S — «камни». Нужно определить, какое количество символов из S одновременно являются «драгоценностями». Проще говоря, нужно проверить, какое количество символов из S входит в J.

Это очень простая разминочная задача, к которой прилагаются решения на нескольких языках программирования, чтобы участники могли освоиться с проверяющей системой.

Алгоритм достаточно простой: из строки с «драгоценностями» необходимо построить множество, затем пройтись по строке с «камнями» и каждый символ проверить на вхождение в это множество. Используйте такую реализацию множества, чтобы гарантировать линейную сложность полученного решения, несмотря на то, что входные строки очень короткие и поэтому возможно сдать даже квадратичный по сложности алгоритм.

### Задача B. Последовательно идущие единицы

> Требуется найти в бинарном векторе самую длинную последовательность единиц и вывести её длину.

Алгоритм решения следующий: пройтись по всем элементам массива; встретив единицу, нужно увеличить счётчик длины текущей последовательности, а, встретив ноль, нужно обнулить этот счётчик. В конце нужно вывести максимальное из значений, которые принимал счётчик.

Проверьте, что правильно обрабатываете ситуацию, когда массив заканчивается на искомую последовательность единиц. При аккуратной реализации такая ситуация не потребует специальной обработки.

Постарайтесь использовать лишь константный объём дополнительной памяти.

### Задача C. Удаление дубликатов

> Дан упорядоченный по неубыванию массив целых 32-разрядных чисел. Требуется удалить из него все повторения.

Правильный алгоритм последовательно обрабатывает элементы массива, сравнивая их с последним выведенным. Нужно не забыть обновлять переменную, содержащую последний выведенный элемент и, кроме того, не ошибиться при обработке последнего элемента.

При решении этой задачи также не нужно использовать дополнительную память.

### Задача D. Генерация скобочных последовательностей

> Дано целое число n. Требуется вывести все правильные скобочные последовательности длины 2 \* n, упорядоченные лексикографически (см. https://ru.wikipedia.org/wiki/Лексикографический_порядок). В задаче используются только круглые скобки.

Это пример относительно сложной алгоритмической задачи. Будем генерировать последовательность по одному символу; в каждый момент мы можем к текущей последовательности приписать либо открывающую скобку, либо закрывающую. Открывающую скобку можно дописать, если до этого было добавлено менее n открывающих скобок, а закрывающую — если в текущей последовательности количество открывающих скобок превосходит количество закрывающих. Такой алгоритм при аккуратной реализации автоматически гарантирует лексикографический порядок в ответе; работает за время, пропорциональное произведению количества элементов в ответе на n; при этом требует линейное количество дополнительной памяти.

Примером неэффективного алгоритма был бы следующий: сгенерируем все возможные скобочные последовательности, а затем выведем лишь те из них, что окажутся правильными. При этом объём ответа не позволит решить задачу быстрее, чем тот алгоритм, что приведёт выше.

### Задача E. Анаграммы

Эта достаточно простая задача — типичный пример задачи, для решения которой необходимо использовать ассоциативные массивы. При решении нужно учитывать, что символы могут повторяться, поэтому необходимо использовать не множества, а словари. Поэтому решение будет следующим: составим из каждой строки по словарю, который для каждого символа будет хранить количество его повторений; затем сравним получившиеся словари. Если они совпадают, необходимо вывести единицу, в противном случае — ноль.

Альтернативное решение: отсортируем входные строки, а затем сравним их. Это решение хуже в том, что оно работает медленнее, а также меняет входные данные. Зато такое решение не использует дополнительной памяти.

Если в процессе собеседования у вас возникло несколько вариантов решения, отличающихся своими по своим характеристикам, расскажите об этом. Всегда здорово, когда разработчик знает несколько вариантов решения задачи и может рассказать об их сильных и слабых сторонах.

### Задача F. Слияние k сортированных списков

> Даны k отсортированных в порядке неубывания массивов неотрицательных целых чисел, каждое из которых не превосходит 100. Требуется построить результат их слияния: отсортированный в порядке неубывания массив, содержащий все элементы исходных k массивов. Длина каждого массива не превосходит 10 \* k.

Для каждого массива создадим по указателю; изначально каждый указатель расположен в начале соответствующего массива. Элементы, соответствующие позициям указателей, поместим в любую структуру данных, которая поддерживает извлечение минимума — это может быть мультимножество или, например, куча. Далее будем извлекать из этой структуры минимальный элемент, помещать его в ответ, сдвигать позицию указателя в соответствующем массиве и помещать в структуру данных очередной элемент из этого массива.

В этой задаче многие испытывают сложности с форматом ввода. Обратите внимание на то, что первые элементы строк не описывают элементы массивов, они описывают длины массивов!

#### Answer #1:

> В данном коде мы создаем структуру Item, которая содержит значение элемента, номер массива, из которого был взят элемент, и индекс элемента в массиве. Затем мы создаем приоритетную очередь PriorityQueue на основе этой структуры, которая будет использоваться для извлечения минимального элемента.
>
> Далее мы создаем указатели на начало каждого массива и добавляем первые элементы каждого массива в приоритетную очередь. Затем мы начинаем извлекать минимальные элементы из очереди, добавляя их в результирующий массив и сдвигая указатель на соответствующий массив. Если указатель не достиг конца массива, мы добавляем следующий элемент из этого массива в приоритетную очередь.
>
> В итоге мы получаем отсортированный в порядке неубывания массив, содержащий все элементы исходных k массивов. В примере выше мы передаем в функцию mergeArrays три отсортированных массива и получаем отсортированный массив [0 0 3 5 6 6 7 28].

#### Answer #2:

> В этом коде мы используем те же самые структуры данных и алгоритм, что и в предыдущем примере, но более лаконично записываем код. Мы создаем массив pointers для хранения указателей на текущий элемент в каждом массиве, инициализируем его нулями и используем его для проверки достижения конца каждого массива.
>
> Также мы используем оператор append для добавления элементов в результирующий массив, вместо явного указания индекса. Это делает код более читаемым и лаконичным.
>
> В итоге мы получаем тот же отсортированный в порядке неубывания массив, содержащий все элементы исходных k массивов.

#### Answer #3:

> Этот код считывает количество массивов k, затем считывает каждый массив и его элементы, сливает массивы в один отсортированный массив и выводит его элементы. Для слияния массивов используется куча, которая поддерживает извлечение минимума и добавление элементов. Код также содержит функции для построения кучи и поддержания ее свойств.

## [/leetcode](./leetcode/)

- [LEETCODE PATTERNS](https://seanprashad.com/leetcode-patterns/)

### linked lists:

- [23. Merge k Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/)
- [141. Linked List Cycle](https://leetcode.com/problems/linked-list-cycle/)
- [2. Add Two Numbers](https://leetcode.com/problems/add-two-numbers/)
- [206. Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)

### binary search:

- [704. Binary Search](https://leetcode.com/problems/binary-search/)
- [374. Guess Number Higher or Lower](https://leetcode.com/problems/guess-number-higher-or-lower/)
- [74. Search a 2D Matrix](https://leetcode.com/problems/search-a-2d-matrix/)
- [33. Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/)
- [153. Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/)
- [81. Search in Rotated Sorted Array II](https://leetcode.com/problems/search-in-rotated-sorted-array-ii/)

### hash table:

- [136. Single Number](https://leetcode.com/problems/single-number/) - решить за O(1) по памяти
- [1. Two Sum](https://leetcode.com/problems/two-sum/)
- [18. 4Sum](https://leetcode.com/problems/4sum/)
- [49. Group Anagrams](https://leetcode.com/problems/group-anagrams/)
- [242. Valid Anagram](https://leetcode.com/problems/valid-anagram/)
- [438. Find All Anagrams in a String](https://leetcode.com/problems/find-all-anagrams-in-a-string/)

### queue/stack:

- [20. Valid Parentheses](https://leetcode.com/problems/valid-parentheses/)

### dfs/bfs:

- [200. Number of Islands](https://leetcode.com/problems/number-of-islands/)
- [301. Remove Invalid Parentheses](https://leetcode.com/problems/remove-invalid-parentheses/)
- [637. Average of Levels in Binary Tree](https://leetcode.com/problems/average-of-levels-in-binary-tree/)

### sort:

- [56. Merge Intervals](https://leetcode.com/problems/merge-intervals/)

### heap/hash:

- [692. Top K Frequent Words](https://leetcode.com/problems/top-k-frequent-words/)
- [347. Top K Frequent Elements](https://leetcode.com/problems/top-k-frequent-elements/)

### two pointers:

- [11. Container With Most Water](https://leetcode.com/problems/container-with-most-water/)
- [763. Partition Labels](https://leetcode.com/problems/partition-labels/)

### sliding window:

- [480. Sliding Window Median](https://leetcode.com/problems/sliding-window-median/)
- [239. Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/)
- [424. Longest Repeating Character Replacement](https://leetcode.com/problems/longest-repeating-character-replacement/)

### tree:

- [100. Same Tree](https://leetcode.com/problems/same-tree/)
- [101. Symmetric Tree](https://leetcode.com/problems/symmetric-tree/)
- [110. Balanced Binary Tree](https://leetcode.com/problems/balanced-binary-tree/)
- [113. Path Sum II](https://leetcode.com/problems/path-sum-ii/)

### greedy problems:

- [121. Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)
- [122. Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/)
- [714. Best Time to Buy and Sell Stock with Transaction Fee](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/)
- [309. Best Time to Buy and Sell Stock with Cooldown](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)

## Успеваемость

![performance](/assets/performance.png)
Итого 835 повторов задач, минимум по 20 раз каждую. 🤓 [тынц](https://docs.google.com/spreadsheets/d/1X45zJ7N6ZWw-byRFq0ITaYul07QDJLREMmfhOxsmsdA/edit?usp=sharing)

---

- [coderun.yandex.ru](https://coderun.yandex.ru/)
- [practicum.yandex.ru](https://practicum.yandex.ru/profile/algorithms-interview/)
- [academy.yandex.ru](https://academy.yandex.ru/)
